// Code generated by erm. DO NOT EDIT.
package resolvers

import (
	"context"
	"fmt"
	"github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/graphql/dataloaders"
	"github.com/deicod/ermblog/graphql/relay"
	"github.com/deicod/ermblog/orm/gen"
)

type entityHooks struct {
	BeforeCreateCategory func(ctx context.Context, r *Resolver, input graphql.CreateCategoryInput, model *gen.Category) error
	AfterCreateCategory  func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeUpdateCategory func(ctx context.Context, r *Resolver, input graphql.UpdateCategoryInput, model *gen.Category) error
	AfterUpdateCategory  func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeDeleteCategory func(ctx context.Context, r *Resolver, input graphql.DeleteCategoryInput, id string) error
	AfterDeleteCategory  func(ctx context.Context, r *Resolver, input graphql.DeleteCategoryInput, id string) error
	BeforeReturnCategory func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeCreateComment  func(ctx context.Context, r *Resolver, input graphql.CreateCommentInput, model *gen.Comment) error
	AfterCreateComment   func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeUpdateComment  func(ctx context.Context, r *Resolver, input graphql.UpdateCommentInput, model *gen.Comment) error
	AfterUpdateComment   func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeDeleteComment  func(ctx context.Context, r *Resolver, input graphql.DeleteCommentInput, id string) error
	AfterDeleteComment   func(ctx context.Context, r *Resolver, input graphql.DeleteCommentInput, id string) error
	BeforeReturnComment  func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeCreatePost     func(ctx context.Context, r *Resolver, input graphql.CreatePostInput, model *gen.Post) error
	AfterCreatePost      func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeUpdatePost     func(ctx context.Context, r *Resolver, input graphql.UpdatePostInput, model *gen.Post) error
	AfterUpdatePost      func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeDeletePost     func(ctx context.Context, r *Resolver, input graphql.DeletePostInput, id string) error
	AfterDeletePost      func(ctx context.Context, r *Resolver, input graphql.DeletePostInput, id string) error
	BeforeReturnPost     func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeCreateTag      func(ctx context.Context, r *Resolver, input graphql.CreateTagInput, model *gen.Tag) error
	AfterCreateTag       func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeUpdateTag      func(ctx context.Context, r *Resolver, input graphql.UpdateTagInput, model *gen.Tag) error
	AfterUpdateTag       func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeDeleteTag      func(ctx context.Context, r *Resolver, input graphql.DeleteTagInput, id string) error
	AfterDeleteTag       func(ctx context.Context, r *Resolver, input graphql.DeleteTagInput, id string) error
	BeforeReturnTag      func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeCreateUser     func(ctx context.Context, r *Resolver, input graphql.CreateUserInput, model *gen.User) error
	AfterCreateUser      func(ctx context.Context, r *Resolver, record *gen.User) error
	BeforeUpdateUser     func(ctx context.Context, r *Resolver, input graphql.UpdateUserInput, model *gen.User) error
	AfterUpdateUser      func(ctx context.Context, r *Resolver, record *gen.User) error
	BeforeDeleteUser     func(ctx context.Context, r *Resolver, input graphql.DeleteUserInput, id string) error
	AfterDeleteUser      func(ctx context.Context, r *Resolver, input graphql.DeleteUserInput, id string) error
	BeforeReturnUser     func(ctx context.Context, r *Resolver, record *gen.User) error
}

func (r *Resolver) applyBeforeCreateCategory(ctx context.Context, input graphql.CreateCategoryInput, model *gen.Category) error {
	if r == nil || r.hooks.BeforeCreateCategory == nil {
		return nil
	}
	return r.hooks.BeforeCreateCategory(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.AfterCreateCategory == nil {
		return nil
	}
	return r.hooks.AfterCreateCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateCategory(ctx context.Context, input graphql.UpdateCategoryInput, model *gen.Category) error {
	if r == nil || r.hooks.BeforeUpdateCategory == nil {
		return nil
	}
	return r.hooks.BeforeUpdateCategory(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.AfterUpdateCategory == nil {
		return nil
	}
	return r.hooks.AfterUpdateCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteCategory == nil {
		return nil
	}
	return r.hooks.BeforeDeleteCategory(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput, id string) error {
	if r == nil || r.hooks.AfterDeleteCategory == nil {
		return nil
	}
	return r.hooks.AfterDeleteCategory(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.BeforeReturnCategory == nil {
		return nil
	}
	return r.hooks.BeforeReturnCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateComment(ctx context.Context, input graphql.CreateCommentInput, model *gen.Comment) error {
	if r == nil || r.hooks.BeforeCreateComment == nil {
		return nil
	}
	return r.hooks.BeforeCreateComment(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.AfterCreateComment == nil {
		return nil
	}
	return r.hooks.AfterCreateComment(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateComment(ctx context.Context, input graphql.UpdateCommentInput, model *gen.Comment) error {
	if r == nil || r.hooks.BeforeUpdateComment == nil {
		return nil
	}
	return r.hooks.BeforeUpdateComment(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.AfterUpdateComment == nil {
		return nil
	}
	return r.hooks.AfterUpdateComment(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteComment(ctx context.Context, input graphql.DeleteCommentInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteComment == nil {
		return nil
	}
	return r.hooks.BeforeDeleteComment(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteComment(ctx context.Context, input graphql.DeleteCommentInput, id string) error {
	if r == nil || r.hooks.AfterDeleteComment == nil {
		return nil
	}
	return r.hooks.AfterDeleteComment(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.BeforeReturnComment == nil {
		return nil
	}
	return r.hooks.BeforeReturnComment(ctx, r, record)
}

func (r *Resolver) applyBeforeCreatePost(ctx context.Context, input graphql.CreatePostInput, model *gen.Post) error {
	if r == nil || r.hooks.BeforeCreatePost == nil {
		return nil
	}
	return r.hooks.BeforeCreatePost(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreatePost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.AfterCreatePost == nil {
		return nil
	}
	return r.hooks.AfterCreatePost(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdatePost(ctx context.Context, input graphql.UpdatePostInput, model *gen.Post) error {
	if r == nil || r.hooks.BeforeUpdatePost == nil {
		return nil
	}
	return r.hooks.BeforeUpdatePost(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdatePost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.AfterUpdatePost == nil {
		return nil
	}
	return r.hooks.AfterUpdatePost(ctx, r, record)
}

func (r *Resolver) applyBeforeDeletePost(ctx context.Context, input graphql.DeletePostInput, id string) error {
	if r == nil || r.hooks.BeforeDeletePost == nil {
		return nil
	}
	return r.hooks.BeforeDeletePost(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeletePost(ctx context.Context, input graphql.DeletePostInput, id string) error {
	if r == nil || r.hooks.AfterDeletePost == nil {
		return nil
	}
	return r.hooks.AfterDeletePost(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnPost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.BeforeReturnPost == nil {
		return nil
	}
	return r.hooks.BeforeReturnPost(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateTag(ctx context.Context, input graphql.CreateTagInput, model *gen.Tag) error {
	if r == nil || r.hooks.BeforeCreateTag == nil {
		return nil
	}
	return r.hooks.BeforeCreateTag(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.AfterCreateTag == nil {
		return nil
	}
	return r.hooks.AfterCreateTag(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateTag(ctx context.Context, input graphql.UpdateTagInput, model *gen.Tag) error {
	if r == nil || r.hooks.BeforeUpdateTag == nil {
		return nil
	}
	return r.hooks.BeforeUpdateTag(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.AfterUpdateTag == nil {
		return nil
	}
	return r.hooks.AfterUpdateTag(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteTag(ctx context.Context, input graphql.DeleteTagInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteTag == nil {
		return nil
	}
	return r.hooks.BeforeDeleteTag(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteTag(ctx context.Context, input graphql.DeleteTagInput, id string) error {
	if r == nil || r.hooks.AfterDeleteTag == nil {
		return nil
	}
	return r.hooks.AfterDeleteTag(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.BeforeReturnTag == nil {
		return nil
	}
	return r.hooks.BeforeReturnTag(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateUser(ctx context.Context, input graphql.CreateUserInput, model *gen.User) error {
	if r == nil || r.hooks.BeforeCreateUser == nil {
		return nil
	}
	return r.hooks.BeforeCreateUser(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.AfterCreateUser == nil {
		return nil
	}
	return r.hooks.AfterCreateUser(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateUser(ctx context.Context, input graphql.UpdateUserInput, model *gen.User) error {
	if r == nil || r.hooks.BeforeUpdateUser == nil {
		return nil
	}
	return r.hooks.BeforeUpdateUser(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.AfterUpdateUser == nil {
		return nil
	}
	return r.hooks.AfterUpdateUser(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteUser(ctx context.Context, input graphql.DeleteUserInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteUser == nil {
		return nil
	}
	return r.hooks.BeforeDeleteUser(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteUser(ctx context.Context, input graphql.DeleteUserInput, id string) error {
	if r == nil || r.hooks.AfterDeleteUser == nil {
		return nil
	}
	return r.hooks.AfterDeleteUser(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.BeforeReturnUser == nil {
		return nil
	}
	return r.hooks.BeforeReturnUser(ctx, r, record)
}

func (r *queryResolver) Node(ctx context.Context, id string) (graphql.Node, error) {
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return nil, err
	}
	switch typ {
	case "Category":
		record, err := r.loadCategory(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLCategory(record), nil
	case "Comment":
		record, err := r.loadComment(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnComment(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLComment(record), nil
	case "Post":
		record, err := r.loadPost(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnPost(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLPost(record), nil
	case "Tag":
		record, err := r.loadTag(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnTag(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLTag(record), nil
	case "User":
		record, err := r.loadUser(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnUser(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLUser(record), nil
	default:
		return nil, fmt.Errorf("unknown node type %s", typ)
	}
}

func (r *Resolver) loadCategory(ctx context.Context, id string) (*gen.Category, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Categories().ByID(ctx, id)
}

func (r *Resolver) primeCategory(ctx context.Context, record *gen.Category) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLCategory(record *gen.Category) *graphql.Category {
	if record == nil {
		return nil
	}
	return &graphql.Category{
		ID:          relay.ToGlobalID("Category", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: record.Description,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeCategoryID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Category" {
		return "", fmt.Errorf("invalid id for Category: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Category(ctx context.Context, id string) (*graphql.Category, error) {
	nativeID, err := decodeCategoryID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadCategory(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLCategory(record), nil
}

func (r *queryResolver) Categories(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CategoryConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Categories().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Categories().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CategoryEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
			return nil, err
		}
		r.primeCategory(ctx, record)
		edges[idx] = &graphql.CategoryEdge{
			Cursor: cursor,
			Node:   toGraphQLCategory(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CategoryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateCategory(ctx context.Context, input graphql.CreateCategoryInput) (*graphql.CreateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Category)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateCategory(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Categories().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateCategory(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateCategory(ctx context.Context, input graphql.UpdateCategoryInput) (*graphql.UpdateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Category{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateCategory(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Categories().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateCategory(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput) (*graphql.DeleteCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteCategory(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Categories().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteCategory(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Category", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteCategoryPayload{
		ClientMutationID:  input.ClientMutationID,
		DeletedCategoryID: deletedID,
	}, nil
}

func (r *subscriptionResolver) CategoryCreated(ctx context.Context) (<-chan *graphql.Category, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Category, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Category)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CategoryUpdated(ctx context.Context) (<-chan *graphql.Category, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Category, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Category)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CategoryDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadComment(ctx context.Context, id string) (*gen.Comment, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Comments().ByID(ctx, id)
}

func (r *Resolver) primeComment(ctx context.Context, record *gen.Comment) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLComment(record *gen.Comment) *graphql.Comment {
	if record == nil {
		return nil
	}
	return &graphql.Comment{
		ID:        relay.ToGlobalID("Comment", record.ID),
		PostID:    record.PostID,
		AuthorID:  record.AuthorID,
		ParentID:  record.ParentID,
		Body:      record.Body,
		Status:    toGraphQLEnum[graphql.CommentStatus](record.Status),
		CreatedAt: record.CreatedAt,
		UpdatedAt: record.UpdatedAt,
	}
}

func decodeCommentID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Comment" {
		return "", fmt.Errorf("invalid id for Comment: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Comment(ctx context.Context, id string) (*graphql.Comment, error) {
	nativeID, err := decodeCommentID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadComment(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLComment(record), nil
}

func (r *queryResolver) Comments(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CommentConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Comments().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Comments().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CommentEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnComment(ctx, record); err != nil {
			return nil, err
		}
		r.primeComment(ctx, record)
		edges[idx] = &graphql.CommentEdge{
			Cursor: cursor,
			Node:   toGraphQLComment(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CommentConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateComment(ctx context.Context, input graphql.CreateCommentInput) (*graphql.CreateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Comment)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.PostID != nil {
		model.PostID = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.CommentStatus](*input.Status)
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateComment(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Comments().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateComment(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateComment(ctx context.Context, input graphql.UpdateCommentInput) (*graphql.UpdateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Comment{ID: nativeID}
	if input.PostID != nil {
		model.PostID = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.CommentStatus](*input.Status)
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateComment(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Comments().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateComment(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteComment(ctx context.Context, input graphql.DeleteCommentInput) (*graphql.DeleteCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteComment(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Comments().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteComment(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Comment", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteCommentPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedCommentID: deletedID,
	}, nil
}

func (r *subscriptionResolver) CommentCreated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentUpdated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadPost(ctx context.Context, id string) (*gen.Post, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Posts().ByID(ctx, id)
}

func (r *Resolver) primePost(ctx context.Context, record *gen.Post) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLPost(record *gen.Post) *graphql.Post {
	if record == nil {
		return nil
	}
	return &graphql.Post{
		ID:          relay.ToGlobalID("Post", record.ID),
		AuthorID:    record.AuthorID,
		CategoryID:  record.CategoryID,
		Title:       record.Title,
		Slug:        record.Slug,
		Excerpt:     record.Excerpt,
		Body:        record.Body,
		Status:      toGraphQLEnum[graphql.PostStatus](record.Status),
		IsFeatured:  record.IsFeatured,
		PublishedAt: record.PublishedAt,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodePostID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Post" {
		return "", fmt.Errorf("invalid id for Post: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Post(ctx context.Context, id string) (*graphql.Post, error) {
	nativeID, err := decodePostID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadPost(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLPost(record), nil
}

func (r *queryResolver) Posts(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.PostConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Posts().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Posts().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.PostEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnPost(ctx, record); err != nil {
			return nil, err
		}
		r.primePost(ctx, record)
		edges[idx] = &graphql.PostEdge{
			Cursor: cursor,
			Node:   toGraphQLPost(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.PostConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreatePost(ctx context.Context, input graphql.CreatePostInput) (*graphql.CreatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Post)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.CategoryID != nil {
		model.CategoryID = input.CategoryID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Excerpt != nil {
		model.Excerpt = input.Excerpt
	}
	if input.Body != nil {
		model.Body = input.Body
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.PostStatus](*input.Status)
	}
	if input.IsFeatured != nil {
		model.IsFeatured = *input.IsFeatured
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreatePost(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Posts().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreatePost(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdatePost(ctx context.Context, input graphql.UpdatePostInput) (*graphql.UpdatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Post{ID: nativeID}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.CategoryID != nil {
		model.CategoryID = input.CategoryID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Excerpt != nil {
		model.Excerpt = input.Excerpt
	}
	if input.Body != nil {
		model.Body = input.Body
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.PostStatus](*input.Status)
	}
	if input.IsFeatured != nil {
		model.IsFeatured = *input.IsFeatured
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdatePost(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Posts().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdatePost(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeletePost(ctx context.Context, input graphql.DeletePostInput) (*graphql.DeletePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeletePost(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Posts().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeletePost(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Post", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeletePostPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedPostID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) PostCreated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostUpdated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadTag(ctx context.Context, id string) (*gen.Tag, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Tags().ByID(ctx, id)
}

func (r *Resolver) primeTag(ctx context.Context, record *gen.Tag) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLTag(record *gen.Tag) *graphql.Tag {
	if record == nil {
		return nil
	}
	return &graphql.Tag{
		ID:          relay.ToGlobalID("Tag", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: record.Description,
		Color:       record.Color,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeTagID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Tag" {
		return "", fmt.Errorf("invalid id for Tag: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Tag(ctx context.Context, id string) (*graphql.Tag, error) {
	nativeID, err := decodeTagID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadTag(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLTag(record), nil
}

func (r *queryResolver) Tags(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.TagConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Tags().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Tags().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.TagEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnTag(ctx, record); err != nil {
			return nil, err
		}
		r.primeTag(ctx, record)
		edges[idx] = &graphql.TagEdge{
			Cursor: cursor,
			Node:   toGraphQLTag(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.TagConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateTag(ctx context.Context, input graphql.CreateTagInput) (*graphql.CreateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Tag)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.Color != nil {
		model.Color = input.Color
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateTag(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Tags().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateTag(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateTag(ctx context.Context, input graphql.UpdateTagInput) (*graphql.UpdateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Tag{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.Color != nil {
		model.Color = input.Color
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateTag(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Tags().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateTag(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteTag(ctx context.Context, input graphql.DeleteTagInput) (*graphql.DeleteTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteTag(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Tags().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteTag(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Tag", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteTagPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedTagID:     deletedID,
	}, nil
}

func (r *subscriptionResolver) TagCreated(ctx context.Context) (<-chan *graphql.Tag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Tag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Tag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) TagUpdated(ctx context.Context) (<-chan *graphql.Tag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Tag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Tag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) TagDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadUser(ctx context.Context, id string) (*gen.User, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Users().ByID(ctx, id)
}

func (r *Resolver) primeUser(ctx context.Context, record *gen.User) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLUser(record *gen.User) *graphql.User {
	if record == nil {
		return nil
	}
	return &graphql.User{
		ID:          relay.ToGlobalID("User", record.ID),
		Username:    record.Username,
		Email:       record.Email,
		Slug:        record.Slug,
		DisplayName: record.DisplayName,
		Bio:         record.Bio,
		AvatarURL:   record.AvatarURL,
		Role:        toGraphQLEnum[graphql.UserRole](record.Role),
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeUserID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "User" {
		return "", fmt.Errorf("invalid id for User: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) User(ctx context.Context, id string) (*graphql.User, error) {
	nativeID, err := decodeUserID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadUser(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLUser(record), nil
}

func (r *queryResolver) Users(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.UserConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Users().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Users().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.UserEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnUser(ctx, record); err != nil {
			return nil, err
		}
		r.primeUser(ctx, record)
		edges[idx] = &graphql.UserEdge{
			Cursor: cursor,
			Node:   toGraphQLUser(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.UserConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateUser(ctx context.Context, input graphql.CreateUserInput) (*graphql.CreateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.User)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.DisplayName != nil {
		model.DisplayName = input.DisplayName
	}
	if input.Bio != nil {
		model.Bio = input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarURL = input.AvatarURL
	}
	if input.Role != nil {
		model.Role = fromGraphQLEnum[graphql.UserRole](*input.Role)
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateUser(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Users().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateUser(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateUser(ctx context.Context, input graphql.UpdateUserInput) (*graphql.UpdateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.User{ID: nativeID}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.DisplayName != nil {
		model.DisplayName = input.DisplayName
	}
	if input.Bio != nil {
		model.Bio = input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarURL = input.AvatarURL
	}
	if input.Role != nil {
		model.Role = fromGraphQLEnum[graphql.UserRole](*input.Role)
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateUser(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Users().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateUser(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteUser(ctx context.Context, input graphql.DeleteUserInput) (*graphql.DeleteUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteUser(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Users().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteUser(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("User", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteUserPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedUserID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) UserCreated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func toGraphQLEnum[T ~string](value string) T {
	return T(value)
}

func toGraphQLEnumPtr[T ~string](value *string) *T {
	if value == nil {
		return nil
	}
	out := T(*value)
	return &out
}

func fromGraphQLEnum[T ~string](value T) string {
	return string(value)
}

func fromGraphQLEnumPtr[T ~string](value *T) *string {
	if value == nil {
		return nil
	}
	out := string(*value)
	return &out
}
