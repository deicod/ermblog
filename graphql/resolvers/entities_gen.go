// Code generated by erm. DO NOT EDIT.
package resolvers

import (
	"context"
	"fmt"
	"github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/graphql/dataloaders"
	"github.com/deicod/ermblog/graphql/relay"
	"github.com/deicod/ermblog/orm/gen"
)

func (r *queryResolver) Node(ctx context.Context, id string) (graphql.Node, error) {
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return nil, err
	}
	switch typ {
	case "Category":
		record, err := r.loadCategory(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLCategory(record), nil
	case "Comment":
		record, err := r.loadComment(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLComment(record), nil
	case "Post":
		record, err := r.loadPost(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLPost(record), nil
	case "PostTag":
		record, err := r.loadPostTag(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLPostTag(record), nil
	case "Tag":
		record, err := r.loadTag(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLTag(record), nil
	case "User":
		record, err := r.loadUser(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		return toGraphQLUser(record), nil
	default:
		return nil, fmt.Errorf("unknown node type %s", typ)
	}
}

func (r *Resolver) loadCategory(ctx context.Context, id string) (*gen.Category, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Categories().ByID(ctx, id)
}

func (r *Resolver) primeCategory(ctx context.Context, record *gen.Category) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLCategory(record *gen.Category) *graphql.Category {
	if record == nil {
		return nil
	}
	return &graphql.Category{
		ID:          relay.ToGlobalID("Category", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: nullableString(record.Description),
		Color:       nullableString(record.Color),
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeCategoryID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Category" {
		return "", fmt.Errorf("invalid id for Category: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Category(ctx context.Context, id string) (*graphql.Category, error) {
	nativeID, err := decodeCategoryID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadCategory(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLCategory(record), nil
}

func (r *queryResolver) Categories(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CategoryConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Categories().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Categories().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CategoryEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primeCategory(ctx, record)
		edges[idx] = &graphql.CategoryEdge{
			Cursor: cursor,
			Node:   toGraphQLCategory(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CategoryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateCategory(ctx context.Context, input graphql.CreateCategoryInput) (*graphql.CreateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Category)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = *input.Description
	}
	if input.Color != nil {
		model.Color = *input.Color
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Categories().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateCategory(ctx context.Context, input graphql.UpdateCategoryInput) (*graphql.UpdateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Category{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = *input.Description
	}
	if input.Color != nil {
		model.Color = *input.Color
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Categories().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput) (*graphql.DeleteCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.Categories().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Category", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteCategoryPayload{
		ClientMutationID:  input.ClientMutationID,
		DeletedCategoryID: deletedID,
	}, nil
}

func (r *subscriptionResolver) CategoryCreated(ctx context.Context) (<-chan *graphql.Category, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Category, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Category)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CategoryUpdated(ctx context.Context) (<-chan *graphql.Category, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Category, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Category)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CategoryDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Category", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadComment(ctx context.Context, id string) (*gen.Comment, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Comments().ByID(ctx, id)
}

func (r *Resolver) primeComment(ctx context.Context, record *gen.Comment) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLComment(record *gen.Comment) *graphql.Comment {
	if record == nil {
		return nil
	}
	return &graphql.Comment{
		ID:        relay.ToGlobalID("Comment", record.ID),
		PostID:    record.PostId,
		AuthorID:  record.AuthorId,
		ParentID:  nullableString(record.ParentId),
		Body:      record.Body,
		IsEdited:  record.IsEdited,
		CreatedAt: record.CreatedAt,
		UpdatedAt: record.UpdatedAt,
	}
}

func decodeCommentID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Comment" {
		return "", fmt.Errorf("invalid id for Comment: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Comment(ctx context.Context, id string) (*graphql.Comment, error) {
	nativeID, err := decodeCommentID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadComment(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLComment(record), nil
}

func (r *queryResolver) Comments(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CommentConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Comments().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Comments().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CommentEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primeComment(ctx, record)
		edges[idx] = &graphql.CommentEdge{
			Cursor: cursor,
			Node:   toGraphQLComment(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CommentConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateComment(ctx context.Context, input graphql.CreateCommentInput) (*graphql.CreateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Comment)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.PostID != nil {
		model.PostId = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorId = *input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentId = *input.ParentID
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.IsEdited != nil {
		model.IsEdited = *input.IsEdited
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Comments().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateComment(ctx context.Context, input graphql.UpdateCommentInput) (*graphql.UpdateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Comment{ID: nativeID}
	if input.PostID != nil {
		model.PostId = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorId = *input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentId = *input.ParentID
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.IsEdited != nil {
		model.IsEdited = *input.IsEdited
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Comments().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteComment(ctx context.Context, input graphql.DeleteCommentInput) (*graphql.DeleteCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.Comments().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Comment", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteCommentPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedCommentID: deletedID,
	}, nil
}

func (r *subscriptionResolver) CommentCreated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentUpdated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadPost(ctx context.Context, id string) (*gen.Post, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Posts().ByID(ctx, id)
}

func (r *Resolver) primePost(ctx context.Context, record *gen.Post) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLPost(record *gen.Post) *graphql.Post {
	if record == nil {
		return nil
	}
	return &graphql.Post{
		ID:          relay.ToGlobalID("Post", record.ID),
		AuthorID:    record.AuthorId,
		CategoryID:  nullableString(record.CategoryId),
		Title:       record.Title,
		Slug:        record.Slug,
		Excerpt:     nullableString(record.Excerpt),
		Body:        nullableString(record.Body),
		PublishedAt: nullableTime(record.PublishedAt),
		IsPublished: record.IsPublished,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodePostID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Post" {
		return "", fmt.Errorf("invalid id for Post: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Post(ctx context.Context, id string) (*graphql.Post, error) {
	nativeID, err := decodePostID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadPost(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLPost(record), nil
}

func (r *queryResolver) Posts(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.PostConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Posts().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Posts().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.PostEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primePost(ctx, record)
		edges[idx] = &graphql.PostEdge{
			Cursor: cursor,
			Node:   toGraphQLPost(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.PostConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreatePost(ctx context.Context, input graphql.CreatePostInput) (*graphql.CreatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Post)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.AuthorID != nil {
		model.AuthorId = *input.AuthorID
	}
	if input.CategoryID != nil {
		model.CategoryId = *input.CategoryID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Excerpt != nil {
		model.Excerpt = *input.Excerpt
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.PublishedAt != nil {
		model.PublishedAt = *input.PublishedAt
	}
	if input.IsPublished != nil {
		model.IsPublished = *input.IsPublished
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Posts().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdatePost(ctx context.Context, input graphql.UpdatePostInput) (*graphql.UpdatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Post{ID: nativeID}
	if input.AuthorID != nil {
		model.AuthorId = *input.AuthorID
	}
	if input.CategoryID != nil {
		model.CategoryId = *input.CategoryID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Excerpt != nil {
		model.Excerpt = *input.Excerpt
	}
	if input.Body != nil {
		model.Body = *input.Body
	}
	if input.PublishedAt != nil {
		model.PublishedAt = *input.PublishedAt
	}
	if input.IsPublished != nil {
		model.IsPublished = *input.IsPublished
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Posts().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeletePost(ctx context.Context, input graphql.DeletePostInput) (*graphql.DeletePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.Posts().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Post", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeletePostPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedPostID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) PostCreated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostUpdated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadPostTag(ctx context.Context, id string) (*gen.PostTag, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.PostTag(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.PostTags().ByID(ctx, id)
}

func (r *Resolver) primePostTag(ctx context.Context, record *gen.PostTag) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.PostTag(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLPostTag(record *gen.PostTag) *graphql.PostTag {
	if record == nil {
		return nil
	}
	return &graphql.PostTag{
		ID:         relay.ToGlobalID("PostTag", record.ID),
		PostID:     record.PostId,
		TagID:      record.TagId,
		AssignedAt: record.AssignedAt,
		CreatedAt:  record.CreatedAt,
		UpdatedAt:  record.UpdatedAt,
	}
}

func decodePostTagID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "PostTag" {
		return "", fmt.Errorf("invalid id for PostTag: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) PostTag(ctx context.Context, id string) (*graphql.PostTag, error) {
	nativeID, err := decodePostTagID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadPostTag(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLPostTag(record), nil
}

func (r *queryResolver) PostTags(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.PostTagConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.PostTags().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.PostTags().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.PostTagEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primePostTag(ctx, record)
		edges[idx] = &graphql.PostTagEdge{
			Cursor: cursor,
			Node:   toGraphQLPostTag(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.PostTagConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreatePostTag(ctx context.Context, input graphql.CreatePostTagInput) (*graphql.CreatePostTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.PostTag)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.PostID != nil {
		model.PostId = *input.PostID
	}
	if input.TagID != nil {
		model.TagId = *input.TagID
	}
	if input.AssignedAt != nil {
		model.AssignedAt = *input.AssignedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.PostTags().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPostTag(record)
	r.primePostTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreatePostTagPayload{
		ClientMutationID: input.ClientMutationID,
		PostTag:          gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdatePostTag(ctx context.Context, input graphql.UpdatePostTagInput) (*graphql.UpdatePostTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostTagID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.PostTag{ID: nativeID}
	if input.PostID != nil {
		model.PostId = *input.PostID
	}
	if input.TagID != nil {
		model.TagId = *input.TagID
	}
	if input.AssignedAt != nil {
		model.AssignedAt = *input.AssignedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.PostTags().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPostTag(record)
	r.primePostTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdatePostTagPayload{
		ClientMutationID: input.ClientMutationID,
		PostTag:          gqlRecord,
	}, nil
}

func (r *mutationResolver) DeletePostTag(ctx context.Context, input graphql.DeletePostTagInput) (*graphql.DeletePostTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostTagID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.PostTags().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("PostTag", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeletePostTagPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedPostTagID: deletedID,
	}, nil
}

func (r *subscriptionResolver) PostTagCreated(ctx context.Context) (<-chan *graphql.PostTag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.PostTag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.PostTag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostTagUpdated(ctx context.Context) (<-chan *graphql.PostTag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.PostTag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.PostTag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostTagDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "PostTag", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadTag(ctx context.Context, id string) (*gen.Tag, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Tags().ByID(ctx, id)
}

func (r *Resolver) primeTag(ctx context.Context, record *gen.Tag) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLTag(record *gen.Tag) *graphql.Tag {
	if record == nil {
		return nil
	}
	return &graphql.Tag{
		ID:          relay.ToGlobalID("Tag", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: nullableString(record.Description),
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeTagID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Tag" {
		return "", fmt.Errorf("invalid id for Tag: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Tag(ctx context.Context, id string) (*graphql.Tag, error) {
	nativeID, err := decodeTagID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadTag(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLTag(record), nil
}

func (r *queryResolver) Tags(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.TagConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Tags().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Tags().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.TagEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primeTag(ctx, record)
		edges[idx] = &graphql.TagEdge{
			Cursor: cursor,
			Node:   toGraphQLTag(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.TagConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateTag(ctx context.Context, input graphql.CreateTagInput) (*graphql.CreateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Tag)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = *input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Tags().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateTag(ctx context.Context, input graphql.UpdateTagInput) (*graphql.UpdateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Tag{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = *input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Tags().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteTag(ctx context.Context, input graphql.DeleteTagInput) (*graphql.DeleteTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.Tags().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Tag", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteTagPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedTagID:     deletedID,
	}, nil
}

func (r *subscriptionResolver) TagCreated(ctx context.Context) (<-chan *graphql.Tag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Tag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Tag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) TagUpdated(ctx context.Context) (<-chan *graphql.Tag, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Tag, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Tag)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) TagDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Tag", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadUser(ctx context.Context, id string) (*gen.User, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Users().ByID(ctx, id)
}

func (r *Resolver) primeUser(ctx context.Context, record *gen.User) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLUser(record *gen.User) *graphql.User {
	if record == nil {
		return nil
	}
	return &graphql.User{
		ID:          relay.ToGlobalID("User", record.ID),
		Username:    record.Username,
		Email:       record.Email,
		Name:        nullableString(record.Name),
		Bio:         nullableString(record.Bio),
		AvatarURL:   nullableString(record.AvatarUrl),
		DisplayName: record.DisplayName,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeUserID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "User" {
		return "", fmt.Errorf("invalid id for User: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) User(ctx context.Context, id string) (*graphql.User, error) {
	nativeID, err := decodeUserID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadUser(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	return toGraphQLUser(record), nil
}

func (r *queryResolver) Users(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.UserConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Users().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Users().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.UserEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		r.primeUser(ctx, record)
		edges[idx] = &graphql.UserEdge{
			Cursor: cursor,
			Node:   toGraphQLUser(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.UserConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateUser(ctx context.Context, input graphql.CreateUserInput) (*graphql.CreateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.User)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Bio != nil {
		model.Bio = *input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarUrl = *input.AvatarURL
	}
	if input.DisplayName != nil {
		model.DisplayName = *input.DisplayName
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Users().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateUser(ctx context.Context, input graphql.UpdateUserInput) (*graphql.UpdateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.User{ID: nativeID}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Bio != nil {
		model.Bio = *input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarUrl = *input.AvatarURL
	}
	if input.DisplayName != nil {
		model.DisplayName = *input.DisplayName
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	record, err := r.ORM.Users().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteUser(ctx context.Context, input graphql.DeleteUserInput) (*graphql.DeleteUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.ORM.Users().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("User", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteUserPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedUserID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) UserCreated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}
