// Code generated by erm. DO NOT EDIT.
package resolvers

import (
	"context"
	"fmt"
	"github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/graphql/dataloaders"
	"github.com/deicod/ermblog/graphql/relay"
	"github.com/deicod/ermblog/orm/gen"
)

type entityHooks struct {
	BeforeCreateCategory func(ctx context.Context, r *Resolver, input graphql.CreateCategoryInput, model *gen.Category) error
	AfterCreateCategory  func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeUpdateCategory func(ctx context.Context, r *Resolver, input graphql.UpdateCategoryInput, model *gen.Category) error
	AfterUpdateCategory  func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeDeleteCategory func(ctx context.Context, r *Resolver, input graphql.DeleteCategoryInput, id string) error
	AfterDeleteCategory  func(ctx context.Context, r *Resolver, input graphql.DeleteCategoryInput, id string) error
	BeforeReturnCategory func(ctx context.Context, r *Resolver, record *gen.Category) error
	BeforeCreateComment  func(ctx context.Context, r *Resolver, input graphql.CreateCommentInput, model *gen.Comment) error
	AfterCreateComment   func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeUpdateComment  func(ctx context.Context, r *Resolver, input graphql.UpdateCommentInput, model *gen.Comment) error
	AfterUpdateComment   func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeDeleteComment  func(ctx context.Context, r *Resolver, input graphql.DeleteCommentInput, id string) error
	AfterDeleteComment   func(ctx context.Context, r *Resolver, input graphql.DeleteCommentInput, id string) error
	BeforeReturnComment  func(ctx context.Context, r *Resolver, record *gen.Comment) error
	BeforeCreateMedia    func(ctx context.Context, r *Resolver, input graphql.CreateMediaInput, model *gen.Media) error
	AfterCreateMedia     func(ctx context.Context, r *Resolver, record *gen.Media) error
	BeforeUpdateMedia    func(ctx context.Context, r *Resolver, input graphql.UpdateMediaInput, model *gen.Media) error
	AfterUpdateMedia     func(ctx context.Context, r *Resolver, record *gen.Media) error
	BeforeDeleteMedia    func(ctx context.Context, r *Resolver, input graphql.DeleteMediaInput, id string) error
	AfterDeleteMedia     func(ctx context.Context, r *Resolver, input graphql.DeleteMediaInput, id string) error
	BeforeReturnMedia    func(ctx context.Context, r *Resolver, record *gen.Media) error
	BeforeCreateOption   func(ctx context.Context, r *Resolver, input graphql.CreateOptionInput, model *gen.Option) error
	AfterCreateOption    func(ctx context.Context, r *Resolver, record *gen.Option) error
	BeforeUpdateOption   func(ctx context.Context, r *Resolver, input graphql.UpdateOptionInput, model *gen.Option) error
	AfterUpdateOption    func(ctx context.Context, r *Resolver, record *gen.Option) error
	BeforeDeleteOption   func(ctx context.Context, r *Resolver, input graphql.DeleteOptionInput, id string) error
	AfterDeleteOption    func(ctx context.Context, r *Resolver, input graphql.DeleteOptionInput, id string) error
	BeforeReturnOption   func(ctx context.Context, r *Resolver, record *gen.Option) error
	BeforeCreatePost     func(ctx context.Context, r *Resolver, input graphql.CreatePostInput, model *gen.Post) error
	AfterCreatePost      func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeUpdatePost     func(ctx context.Context, r *Resolver, input graphql.UpdatePostInput, model *gen.Post) error
	AfterUpdatePost      func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeDeletePost     func(ctx context.Context, r *Resolver, input graphql.DeletePostInput, id string) error
	AfterDeletePost      func(ctx context.Context, r *Resolver, input graphql.DeletePostInput, id string) error
	BeforeReturnPost     func(ctx context.Context, r *Resolver, record *gen.Post) error
	BeforeCreateRole     func(ctx context.Context, r *Resolver, input graphql.CreateRoleInput, model *gen.Role) error
	AfterCreateRole      func(ctx context.Context, r *Resolver, record *gen.Role) error
	BeforeUpdateRole     func(ctx context.Context, r *Resolver, input graphql.UpdateRoleInput, model *gen.Role) error
	AfterUpdateRole      func(ctx context.Context, r *Resolver, record *gen.Role) error
	BeforeDeleteRole     func(ctx context.Context, r *Resolver, input graphql.DeleteRoleInput, id string) error
	AfterDeleteRole      func(ctx context.Context, r *Resolver, input graphql.DeleteRoleInput, id string) error
	BeforeReturnRole     func(ctx context.Context, r *Resolver, record *gen.Role) error
	BeforeCreateTag      func(ctx context.Context, r *Resolver, input graphql.CreateTagInput, model *gen.Tag) error
	AfterCreateTag       func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeUpdateTag      func(ctx context.Context, r *Resolver, input graphql.UpdateTagInput, model *gen.Tag) error
	AfterUpdateTag       func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeDeleteTag      func(ctx context.Context, r *Resolver, input graphql.DeleteTagInput, id string) error
	AfterDeleteTag       func(ctx context.Context, r *Resolver, input graphql.DeleteTagInput, id string) error
	BeforeReturnTag      func(ctx context.Context, r *Resolver, record *gen.Tag) error
	BeforeCreateUser     func(ctx context.Context, r *Resolver, input graphql.CreateUserInput, model *gen.User) error
	AfterCreateUser      func(ctx context.Context, r *Resolver, record *gen.User) error
	BeforeUpdateUser     func(ctx context.Context, r *Resolver, input graphql.UpdateUserInput, model *gen.User) error
	AfterUpdateUser      func(ctx context.Context, r *Resolver, record *gen.User) error
	BeforeDeleteUser     func(ctx context.Context, r *Resolver, input graphql.DeleteUserInput, id string) error
	AfterDeleteUser      func(ctx context.Context, r *Resolver, input graphql.DeleteUserInput, id string) error
	BeforeReturnUser     func(ctx context.Context, r *Resolver, record *gen.User) error
}

func (r *Resolver) applyBeforeCreateCategory(ctx context.Context, input graphql.CreateCategoryInput, model *gen.Category) error {
	if r == nil || r.hooks.BeforeCreateCategory == nil {
		return nil
	}
	return r.hooks.BeforeCreateCategory(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.AfterCreateCategory == nil {
		return nil
	}
	return r.hooks.AfterCreateCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateCategory(ctx context.Context, input graphql.UpdateCategoryInput, model *gen.Category) error {
	if r == nil || r.hooks.BeforeUpdateCategory == nil {
		return nil
	}
	return r.hooks.BeforeUpdateCategory(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.AfterUpdateCategory == nil {
		return nil
	}
	return r.hooks.AfterUpdateCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteCategory == nil {
		return nil
	}
	return r.hooks.BeforeDeleteCategory(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput, id string) error {
	if r == nil || r.hooks.AfterDeleteCategory == nil {
		return nil
	}
	return r.hooks.AfterDeleteCategory(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnCategory(ctx context.Context, record *gen.Category) error {
	if r == nil || record == nil || r.hooks.BeforeReturnCategory == nil {
		return nil
	}
	return r.hooks.BeforeReturnCategory(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateComment(ctx context.Context, input graphql.CreateCommentInput, model *gen.Comment) error {
	if r == nil || r.hooks.BeforeCreateComment == nil {
		return nil
	}
	return r.hooks.BeforeCreateComment(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.AfterCreateComment == nil {
		return nil
	}
	return r.hooks.AfterCreateComment(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateComment(ctx context.Context, input graphql.UpdateCommentInput, model *gen.Comment) error {
	if r == nil || r.hooks.BeforeUpdateComment == nil {
		return nil
	}
	return r.hooks.BeforeUpdateComment(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.AfterUpdateComment == nil {
		return nil
	}
	return r.hooks.AfterUpdateComment(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteComment(ctx context.Context, input graphql.DeleteCommentInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteComment == nil {
		return nil
	}
	return r.hooks.BeforeDeleteComment(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteComment(ctx context.Context, input graphql.DeleteCommentInput, id string) error {
	if r == nil || r.hooks.AfterDeleteComment == nil {
		return nil
	}
	return r.hooks.AfterDeleteComment(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnComment(ctx context.Context, record *gen.Comment) error {
	if r == nil || record == nil || r.hooks.BeforeReturnComment == nil {
		return nil
	}
	return r.hooks.BeforeReturnComment(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateMedia(ctx context.Context, input graphql.CreateMediaInput, model *gen.Media) error {
	if r == nil || r.hooks.BeforeCreateMedia == nil {
		return nil
	}
	return r.hooks.BeforeCreateMedia(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateMedia(ctx context.Context, record *gen.Media) error {
	if r == nil || record == nil || r.hooks.AfterCreateMedia == nil {
		return nil
	}
	return r.hooks.AfterCreateMedia(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateMedia(ctx context.Context, input graphql.UpdateMediaInput, model *gen.Media) error {
	if r == nil || r.hooks.BeforeUpdateMedia == nil {
		return nil
	}
	return r.hooks.BeforeUpdateMedia(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateMedia(ctx context.Context, record *gen.Media) error {
	if r == nil || record == nil || r.hooks.AfterUpdateMedia == nil {
		return nil
	}
	return r.hooks.AfterUpdateMedia(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteMedia(ctx context.Context, input graphql.DeleteMediaInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteMedia == nil {
		return nil
	}
	return r.hooks.BeforeDeleteMedia(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteMedia(ctx context.Context, input graphql.DeleteMediaInput, id string) error {
	if r == nil || r.hooks.AfterDeleteMedia == nil {
		return nil
	}
	return r.hooks.AfterDeleteMedia(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnMedia(ctx context.Context, record *gen.Media) error {
	if r == nil || record == nil || r.hooks.BeforeReturnMedia == nil {
		return nil
	}
	return r.hooks.BeforeReturnMedia(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateOption(ctx context.Context, input graphql.CreateOptionInput, model *gen.Option) error {
	if r == nil || r.hooks.BeforeCreateOption == nil {
		return nil
	}
	return r.hooks.BeforeCreateOption(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateOption(ctx context.Context, record *gen.Option) error {
	if r == nil || record == nil || r.hooks.AfterCreateOption == nil {
		return nil
	}
	return r.hooks.AfterCreateOption(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateOption(ctx context.Context, input graphql.UpdateOptionInput, model *gen.Option) error {
	if r == nil || r.hooks.BeforeUpdateOption == nil {
		return nil
	}
	return r.hooks.BeforeUpdateOption(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateOption(ctx context.Context, record *gen.Option) error {
	if r == nil || record == nil || r.hooks.AfterUpdateOption == nil {
		return nil
	}
	return r.hooks.AfterUpdateOption(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteOption(ctx context.Context, input graphql.DeleteOptionInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteOption == nil {
		return nil
	}
	return r.hooks.BeforeDeleteOption(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteOption(ctx context.Context, input graphql.DeleteOptionInput, id string) error {
	if r == nil || r.hooks.AfterDeleteOption == nil {
		return nil
	}
	return r.hooks.AfterDeleteOption(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnOption(ctx context.Context, record *gen.Option) error {
	if r == nil || record == nil || r.hooks.BeforeReturnOption == nil {
		return nil
	}
	return r.hooks.BeforeReturnOption(ctx, r, record)
}

func (r *Resolver) applyBeforeCreatePost(ctx context.Context, input graphql.CreatePostInput, model *gen.Post) error {
	if r == nil || r.hooks.BeforeCreatePost == nil {
		return nil
	}
	return r.hooks.BeforeCreatePost(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreatePost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.AfterCreatePost == nil {
		return nil
	}
	return r.hooks.AfterCreatePost(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdatePost(ctx context.Context, input graphql.UpdatePostInput, model *gen.Post) error {
	if r == nil || r.hooks.BeforeUpdatePost == nil {
		return nil
	}
	return r.hooks.BeforeUpdatePost(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdatePost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.AfterUpdatePost == nil {
		return nil
	}
	return r.hooks.AfterUpdatePost(ctx, r, record)
}

func (r *Resolver) applyBeforeDeletePost(ctx context.Context, input graphql.DeletePostInput, id string) error {
	if r == nil || r.hooks.BeforeDeletePost == nil {
		return nil
	}
	return r.hooks.BeforeDeletePost(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeletePost(ctx context.Context, input graphql.DeletePostInput, id string) error {
	if r == nil || r.hooks.AfterDeletePost == nil {
		return nil
	}
	return r.hooks.AfterDeletePost(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnPost(ctx context.Context, record *gen.Post) error {
	if r == nil || record == nil || r.hooks.BeforeReturnPost == nil {
		return nil
	}
	return r.hooks.BeforeReturnPost(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateRole(ctx context.Context, input graphql.CreateRoleInput, model *gen.Role) error {
	if r == nil || r.hooks.BeforeCreateRole == nil {
		return nil
	}
	return r.hooks.BeforeCreateRole(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateRole(ctx context.Context, record *gen.Role) error {
	if r == nil || record == nil || r.hooks.AfterCreateRole == nil {
		return nil
	}
	return r.hooks.AfterCreateRole(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateRole(ctx context.Context, input graphql.UpdateRoleInput, model *gen.Role) error {
	if r == nil || r.hooks.BeforeUpdateRole == nil {
		return nil
	}
	return r.hooks.BeforeUpdateRole(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateRole(ctx context.Context, record *gen.Role) error {
	if r == nil || record == nil || r.hooks.AfterUpdateRole == nil {
		return nil
	}
	return r.hooks.AfterUpdateRole(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteRole(ctx context.Context, input graphql.DeleteRoleInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteRole == nil {
		return nil
	}
	return r.hooks.BeforeDeleteRole(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteRole(ctx context.Context, input graphql.DeleteRoleInput, id string) error {
	if r == nil || r.hooks.AfterDeleteRole == nil {
		return nil
	}
	return r.hooks.AfterDeleteRole(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnRole(ctx context.Context, record *gen.Role) error {
	if r == nil || record == nil || r.hooks.BeforeReturnRole == nil {
		return nil
	}
	return r.hooks.BeforeReturnRole(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateTag(ctx context.Context, input graphql.CreateTagInput, model *gen.Tag) error {
	if r == nil || r.hooks.BeforeCreateTag == nil {
		return nil
	}
	return r.hooks.BeforeCreateTag(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.AfterCreateTag == nil {
		return nil
	}
	return r.hooks.AfterCreateTag(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateTag(ctx context.Context, input graphql.UpdateTagInput, model *gen.Tag) error {
	if r == nil || r.hooks.BeforeUpdateTag == nil {
		return nil
	}
	return r.hooks.BeforeUpdateTag(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.AfterUpdateTag == nil {
		return nil
	}
	return r.hooks.AfterUpdateTag(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteTag(ctx context.Context, input graphql.DeleteTagInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteTag == nil {
		return nil
	}
	return r.hooks.BeforeDeleteTag(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteTag(ctx context.Context, input graphql.DeleteTagInput, id string) error {
	if r == nil || r.hooks.AfterDeleteTag == nil {
		return nil
	}
	return r.hooks.AfterDeleteTag(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnTag(ctx context.Context, record *gen.Tag) error {
	if r == nil || record == nil || r.hooks.BeforeReturnTag == nil {
		return nil
	}
	return r.hooks.BeforeReturnTag(ctx, r, record)
}

func (r *Resolver) applyBeforeCreateUser(ctx context.Context, input graphql.CreateUserInput, model *gen.User) error {
	if r == nil || r.hooks.BeforeCreateUser == nil {
		return nil
	}
	return r.hooks.BeforeCreateUser(ctx, r, input, model)
}

func (r *Resolver) applyAfterCreateUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.AfterCreateUser == nil {
		return nil
	}
	return r.hooks.AfterCreateUser(ctx, r, record)
}

func (r *Resolver) applyBeforeUpdateUser(ctx context.Context, input graphql.UpdateUserInput, model *gen.User) error {
	if r == nil || r.hooks.BeforeUpdateUser == nil {
		return nil
	}
	return r.hooks.BeforeUpdateUser(ctx, r, input, model)
}

func (r *Resolver) applyAfterUpdateUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.AfterUpdateUser == nil {
		return nil
	}
	return r.hooks.AfterUpdateUser(ctx, r, record)
}

func (r *Resolver) applyBeforeDeleteUser(ctx context.Context, input graphql.DeleteUserInput, id string) error {
	if r == nil || r.hooks.BeforeDeleteUser == nil {
		return nil
	}
	return r.hooks.BeforeDeleteUser(ctx, r, input, id)
}

func (r *Resolver) applyAfterDeleteUser(ctx context.Context, input graphql.DeleteUserInput, id string) error {
	if r == nil || r.hooks.AfterDeleteUser == nil {
		return nil
	}
	return r.hooks.AfterDeleteUser(ctx, r, input, id)
}

func (r *Resolver) applyBeforeReturnUser(ctx context.Context, record *gen.User) error {
	if r == nil || record == nil || r.hooks.BeforeReturnUser == nil {
		return nil
	}
	return r.hooks.BeforeReturnUser(ctx, r, record)
}

func (r *queryResolver) Node(ctx context.Context, id string) (graphql.Node, error) {
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return nil, err
	}
	switch typ {
	case "Category":
		record, err := r.loadCategory(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLCategory(record), nil
	case "Comment":
		record, err := r.loadComment(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnComment(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLComment(record), nil
	case "Media":
		record, err := r.loadMedia(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnMedia(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLMedia(record), nil
	case "Option":
		record, err := r.loadOption(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnOption(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLOption(record), nil
	case "Post":
		record, err := r.loadPost(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnPost(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLPost(record), nil
	case "Role":
		record, err := r.loadRole(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnRole(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLRole(record), nil
	case "Tag":
		record, err := r.loadTag(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnTag(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLTag(record), nil
	case "User":
		record, err := r.loadUser(ctx, nativeID)
		if err != nil {
			return nil, err
		}
		if record == nil {
			return nil, nil
		}
		if err := r.applyBeforeReturnUser(ctx, record); err != nil {
			return nil, err
		}
		return toGraphQLUser(record), nil
	default:
		return nil, fmt.Errorf("unknown node type %s", typ)
	}
}

func (r *Resolver) loadCategory(ctx context.Context, id string) (*gen.Category, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Categories().ByID(ctx, id)
}

func (r *Resolver) primeCategory(ctx context.Context, record *gen.Category) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Category(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLCategory(record *gen.Category) *graphql.Category {
	if record == nil {
		return nil
	}
	return &graphql.Category{
		ID:          relay.ToGlobalID("Category", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: record.Description,
		ParentID:    record.ParentID,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeCategoryID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Category" {
		return "", fmt.Errorf("invalid id for Category: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Category(ctx context.Context, id string) (*graphql.Category, error) {
	nativeID, err := decodeCategoryID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadCategory(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLCategory(record), nil
}

func (r *queryResolver) Categories(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CategoryConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Categories().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Categories().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CategoryEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
			return nil, err
		}
		r.primeCategory(ctx, record)
		edges[idx] = &graphql.CategoryEdge{
			Cursor: cursor,
			Node:   toGraphQLCategory(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CategoryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateCategory(ctx context.Context, input graphql.CreateCategoryInput) (*graphql.CreateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Category)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateCategory(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Categories().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateCategory(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	return &graphql.CreateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateCategory(ctx context.Context, input graphql.UpdateCategoryInput) (*graphql.UpdateCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Category{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateCategory(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Categories().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateCategory(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnCategory(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLCategory(record)
	r.primeCategory(ctx, record)
	return &graphql.UpdateCategoryPayload{
		ClientMutationID: input.ClientMutationID,
		Category:         gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteCategory(ctx context.Context, input graphql.DeleteCategoryInput) (*graphql.DeleteCategoryPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCategoryID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteCategory(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Categories().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteCategory(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Category", nativeID)
	return &graphql.DeleteCategoryPayload{
		ClientMutationID:  input.ClientMutationID,
		DeletedCategoryID: deletedID,
	}, nil
}

func (r *Resolver) loadComment(ctx context.Context, id string) (*gen.Comment, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Comments().ByID(ctx, id)
}

func (r *Resolver) primeComment(ctx context.Context, record *gen.Comment) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Comment(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLComment(record *gen.Comment) *graphql.Comment {
	if record == nil {
		return nil
	}
	return &graphql.Comment{
		ID:          relay.ToGlobalID("Comment", record.ID),
		PostID:      record.PostID,
		AuthorID:    record.AuthorID,
		ParentID:    record.ParentID,
		AuthorName:  record.AuthorName,
		AuthorEmail: record.AuthorEmail,
		AuthorURL:   record.AuthorURL,
		Content:     record.Content,
		Status:      toGraphQLEnum[graphql.CommentStatus](record.Status),
		SubmittedAt: record.SubmittedAt,
		PublishedAt: record.PublishedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeCommentID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Comment" {
		return "", fmt.Errorf("invalid id for Comment: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Comment(ctx context.Context, id string) (*graphql.Comment, error) {
	nativeID, err := decodeCommentID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadComment(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLComment(record), nil
}

func (r *queryResolver) Comments(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.CommentConnection, error) {
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	repo := r.commentRepository()
	if repo == nil {
		return nil, fmt.Errorf("comment repository is not configured")
	}
	query := repo.Query()
	if query == nil {
		return &graphql.CommentConnection{
			Edges:    []*graphql.CommentEdge{},
			PageInfo: &graphql.PageInfo{HasNextPage: false, HasPreviousPage: false},
		}, nil
	}
	query = query.OrderBySubmittedAtDesc()
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := query.Count(ctx)
	if err != nil {
		return nil, err
	}
	if offset > 0 {
		query = query.Offset(offset)
	}
	if limit > 0 {
		query = query.Limit(limit)
	}
	records, err := query.All(ctx)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.CommentEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnComment(ctx, record); err != nil {
			return nil, err
		}
		r.primeComment(ctx, record)
		edges[idx] = &graphql.CommentEdge{
			Cursor: cursor,
			Node:   toGraphQLComment(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.CommentConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateComment(ctx context.Context, input graphql.CreateCommentInput) (*graphql.CreateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Comment)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.PostID != nil {
		model.PostID = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorID = input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.AuthorName != nil {
		model.AuthorName = input.AuthorName
	}
	if input.AuthorEmail != nil {
		model.AuthorEmail = input.AuthorEmail
	}
	if input.AuthorURL != nil {
		model.AuthorURL = input.AuthorURL
	}
	if input.Content != nil {
		model.Content = *input.Content
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.CommentStatus](*input.Status)
	}
	if input.SubmittedAt != nil {
		model.SubmittedAt = *input.SubmittedAt
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateComment(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Comments().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateComment(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateComment(ctx context.Context, input graphql.UpdateCommentInput) (*graphql.UpdateCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Comment{ID: nativeID}
	if input.PostID != nil {
		model.PostID = *input.PostID
	}
	if input.AuthorID != nil {
		model.AuthorID = input.AuthorID
	}
	if input.ParentID != nil {
		model.ParentID = input.ParentID
	}
	if input.AuthorName != nil {
		model.AuthorName = input.AuthorName
	}
	if input.AuthorEmail != nil {
		model.AuthorEmail = input.AuthorEmail
	}
	if input.AuthorURL != nil {
		model.AuthorURL = input.AuthorURL
	}
	if input.Content != nil {
		model.Content = *input.Content
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.CommentStatus](*input.Status)
	}
	if input.SubmittedAt != nil {
		model.SubmittedAt = *input.SubmittedAt
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateComment(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Comments().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateComment(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnComment(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLComment(record)
	r.primeComment(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateCommentPayload{
		ClientMutationID: input.ClientMutationID,
		Comment:          gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteComment(ctx context.Context, input graphql.DeleteCommentInput) (*graphql.DeleteCommentPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeCommentID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteComment(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Comments().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteComment(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Comment", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteCommentPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedCommentID: deletedID,
	}, nil
}

func (r *subscriptionResolver) CommentCreated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentUpdated(ctx context.Context) (<-chan *graphql.Comment, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Comment, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Comment)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) CommentDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Comment", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadMedia(ctx context.Context, id string) (*gen.Media, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Media(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Medias().ByID(ctx, id)
}

func (r *Resolver) primeMedia(ctx context.Context, record *gen.Media) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Media(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLMedia(record *gen.Media) *graphql.Media {
	if record == nil {
		return nil
	}
	return &graphql.Media{
		ID:            relay.ToGlobalID("Media", record.ID),
		UploadedByID:  record.UploadedByID,
		FileName:      record.FileName,
		MimeType:      record.MimeType,
		StorageKey:    record.StorageKey,
		URL:           record.URL,
		Title:         record.Title,
		AltText:       record.AltText,
		Caption:       record.Caption,
		Description:   record.Description,
		FileSizeBytes: toGraphQLIntPtr(record.FileSizeBytes),
		Metadata:      record.Metadata,
		CreatedAt:     record.CreatedAt,
		UpdatedAt:     record.UpdatedAt,
	}
}

func decodeMediaID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Media" {
		return "", fmt.Errorf("invalid id for Media: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Media(ctx context.Context, id string) (*graphql.Media, error) {
	nativeID, err := decodeMediaID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadMedia(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnMedia(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLMedia(record), nil
}

func (r *queryResolver) Medias(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.MediaConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Medias().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Medias().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.MediaEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnMedia(ctx, record); err != nil {
			return nil, err
		}
		r.primeMedia(ctx, record)
		edges[idx] = &graphql.MediaEdge{
			Cursor: cursor,
			Node:   toGraphQLMedia(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.MediaConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateMedia(ctx context.Context, input graphql.CreateMediaInput) (*graphql.CreateMediaPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Media)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.UploadedByID != nil {
		model.UploadedByID = input.UploadedByID
	}
	if input.FileName != nil {
		model.FileName = *input.FileName
	}
	if input.MimeType != nil {
		model.MimeType = *input.MimeType
	}
	if input.StorageKey != nil {
		model.StorageKey = *input.StorageKey
	}
	if input.URL != nil {
		model.URL = *input.URL
	}
	if input.Title != nil {
		model.Title = input.Title
	}
	if input.AltText != nil {
		model.AltText = input.AltText
	}
	if input.Caption != nil {
		model.Caption = input.Caption
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.FileSizeBytes != nil {
		value := int32(*input.FileSizeBytes)
		model.FileSizeBytes = &value
	}
	if input.Metadata != nil {
		model.Metadata = input.Metadata
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateMedia(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Medias().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateMedia(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnMedia(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLMedia(record)
	r.primeMedia(ctx, record)
	return &graphql.CreateMediaPayload{
		ClientMutationID: input.ClientMutationID,
		Media:            gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateMedia(ctx context.Context, input graphql.UpdateMediaInput) (*graphql.UpdateMediaPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeMediaID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Media{ID: nativeID}
	if input.UploadedByID != nil {
		model.UploadedByID = input.UploadedByID
	}
	if input.FileName != nil {
		model.FileName = *input.FileName
	}
	if input.MimeType != nil {
		model.MimeType = *input.MimeType
	}
	if input.StorageKey != nil {
		model.StorageKey = *input.StorageKey
	}
	if input.URL != nil {
		model.URL = *input.URL
	}
	if input.Title != nil {
		model.Title = input.Title
	}
	if input.AltText != nil {
		model.AltText = input.AltText
	}
	if input.Caption != nil {
		model.Caption = input.Caption
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.FileSizeBytes != nil {
		value := int32(*input.FileSizeBytes)
		model.FileSizeBytes = &value
	}
	if input.Metadata != nil {
		model.Metadata = input.Metadata
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateMedia(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Medias().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateMedia(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnMedia(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLMedia(record)
	r.primeMedia(ctx, record)
	return &graphql.UpdateMediaPayload{
		ClientMutationID: input.ClientMutationID,
		Media:            gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteMedia(ctx context.Context, input graphql.DeleteMediaInput) (*graphql.DeleteMediaPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeMediaID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteMedia(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Medias().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteMedia(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Media", nativeID)
	return &graphql.DeleteMediaPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedMediaID:   deletedID,
	}, nil
}

func (r *Resolver) loadOption(ctx context.Context, id string) (*gen.Option, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Option(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Options().ByID(ctx, id)
}

func (r *Resolver) primeOption(ctx context.Context, record *gen.Option) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Option(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLOption(record *gen.Option) *graphql.Option {
	if record == nil {
		return nil
	}
	return &graphql.Option{
		ID:        relay.ToGlobalID("Option", record.ID),
		Name:      record.Name,
		Value:     record.Value,
		Autoload:  record.Autoload,
		CreatedAt: record.CreatedAt,
		UpdatedAt: record.UpdatedAt,
	}
}

func decodeOptionID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Option" {
		return "", fmt.Errorf("invalid id for Option: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Option(ctx context.Context, id string) (*graphql.Option, error) {
	nativeID, err := decodeOptionID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadOption(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnOption(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLOption(record), nil
}

func (r *queryResolver) Options(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.OptionConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Options().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Options().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.OptionEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnOption(ctx, record); err != nil {
			return nil, err
		}
		r.primeOption(ctx, record)
		edges[idx] = &graphql.OptionEdge{
			Cursor: cursor,
			Node:   toGraphQLOption(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.OptionConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateOption(ctx context.Context, input graphql.CreateOptionInput) (*graphql.CreateOptionPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Option)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Value != nil {
		model.Value = input.Value
	}
	if input.Autoload != nil {
		model.Autoload = *input.Autoload
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateOption(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Options().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateOption(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnOption(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLOption(record)
	r.primeOption(ctx, record)
	return &graphql.CreateOptionPayload{
		ClientMutationID: input.ClientMutationID,
		Option:           gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateOption(ctx context.Context, input graphql.UpdateOptionInput) (*graphql.UpdateOptionPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeOptionID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Option{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Value != nil {
		model.Value = input.Value
	}
	if input.Autoload != nil {
		model.Autoload = *input.Autoload
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateOption(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Options().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateOption(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnOption(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLOption(record)
	r.primeOption(ctx, record)
	return &graphql.UpdateOptionPayload{
		ClientMutationID: input.ClientMutationID,
		Option:           gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteOption(ctx context.Context, input graphql.DeleteOptionInput) (*graphql.DeleteOptionPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeOptionID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteOption(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Options().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteOption(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Option", nativeID)
	return &graphql.DeleteOptionPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedOptionID:  deletedID,
	}, nil
}

func (r *Resolver) loadPost(ctx context.Context, id string) (*gen.Post, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Posts().ByID(ctx, id)
}

func (r *Resolver) primePost(ctx context.Context, record *gen.Post) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Post(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLPost(record *gen.Post) *graphql.Post {
	if record == nil {
		return nil
	}
	return &graphql.Post{
		ID:              relay.ToGlobalID("Post", record.ID),
		AuthorID:        record.AuthorID,
		FeaturedMediaID: record.FeaturedMediaID,
		Title:           record.Title,
		Slug:            record.Slug,
		Status:          toGraphQLEnum[graphql.PostStatus](record.Status),
		Type:            toGraphQLEnum[graphql.PostType](record.Type),
		Excerpt:         record.Excerpt,
		Content:         record.Content,
		Seo:             record.Seo,
		PublishedAt:     record.PublishedAt,
		CreatedAt:       record.CreatedAt,
		UpdatedAt:       record.UpdatedAt,
	}
}

func decodePostID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Post" {
		return "", fmt.Errorf("invalid id for Post: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Post(ctx context.Context, id string) (*graphql.Post, error) {
	nativeID, err := decodePostID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadPost(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLPost(record), nil
}

func (r *queryResolver) Posts(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.PostConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Posts().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Posts().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.PostEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnPost(ctx, record); err != nil {
			return nil, err
		}
		r.primePost(ctx, record)
		edges[idx] = &graphql.PostEdge{
			Cursor: cursor,
			Node:   toGraphQLPost(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.PostConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreatePost(ctx context.Context, input graphql.CreatePostInput) (*graphql.CreatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Post)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.FeaturedMediaID != nil {
		model.FeaturedMediaID = input.FeaturedMediaID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.PostStatus](*input.Status)
	}
	if input.Type != nil {
		model.Type = fromGraphQLEnum[graphql.PostType](*input.Type)
	}
	if input.Excerpt != nil {
		model.Excerpt = input.Excerpt
	}
	if input.Content != nil {
		model.Content = input.Content
	}
	if input.Seo != nil {
		model.Seo = input.Seo
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreatePost(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Posts().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreatePost(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdatePost(ctx context.Context, input graphql.UpdatePostInput) (*graphql.UpdatePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Post{ID: nativeID}
	if input.AuthorID != nil {
		model.AuthorID = *input.AuthorID
	}
	if input.FeaturedMediaID != nil {
		model.FeaturedMediaID = input.FeaturedMediaID
	}
	if input.Title != nil {
		model.Title = *input.Title
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Status != nil {
		model.Status = fromGraphQLEnum[graphql.PostStatus](*input.Status)
	}
	if input.Type != nil {
		model.Type = fromGraphQLEnum[graphql.PostType](*input.Type)
	}
	if input.Excerpt != nil {
		model.Excerpt = input.Excerpt
	}
	if input.Content != nil {
		model.Content = input.Content
	}
	if input.Seo != nil {
		model.Seo = input.Seo
	}
	if input.PublishedAt != nil {
		model.PublishedAt = input.PublishedAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdatePost(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Posts().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdatePost(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnPost(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLPost(record)
	r.primePost(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdatePostPayload{
		ClientMutationID: input.ClientMutationID,
		Post:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeletePost(ctx context.Context, input graphql.DeletePostInput) (*graphql.DeletePostPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodePostID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeletePost(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Posts().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeletePost(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Post", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeletePostPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedPostID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) PostCreated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostUpdated(ctx context.Context) (<-chan *graphql.Post, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Post, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Post)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) PostDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Post", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadRole(ctx context.Context, id string) (*gen.Role, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Role(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Roles().ByID(ctx, id)
}

func (r *Resolver) primeRole(ctx context.Context, record *gen.Role) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Role(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLRole(record *gen.Role) *graphql.Role {
	if record == nil {
		return nil
	}
	return &graphql.Role{
		ID:           relay.ToGlobalID("Role", record.ID),
		Name:         record.Name,
		Slug:         record.Slug,
		Description:  record.Description,
		Capabilities: record.Capabilities,
		CreatedAt:    record.CreatedAt,
		UpdatedAt:    record.UpdatedAt,
	}
}

func decodeRoleID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Role" {
		return "", fmt.Errorf("invalid id for Role: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Role(ctx context.Context, id string) (*graphql.Role, error) {
	nativeID, err := decodeRoleID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadRole(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnRole(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLRole(record), nil
}

func (r *queryResolver) Roles(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.RoleConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Roles().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Roles().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.RoleEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnRole(ctx, record); err != nil {
			return nil, err
		}
		r.primeRole(ctx, record)
		edges[idx] = &graphql.RoleEdge{
			Cursor: cursor,
			Node:   toGraphQLRole(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.RoleConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateRole(ctx context.Context, input graphql.CreateRoleInput) (*graphql.CreateRolePayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Role)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.Capabilities != nil {
		model.Capabilities = input.Capabilities
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateRole(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Roles().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateRole(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnRole(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLRole(record)
	r.primeRole(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateRolePayload{
		ClientMutationID: input.ClientMutationID,
		Role:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateRole(ctx context.Context, input graphql.UpdateRoleInput) (*graphql.UpdateRolePayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeRoleID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Role{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.Capabilities != nil {
		model.Capabilities = input.Capabilities
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateRole(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Roles().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateRole(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnRole(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLRole(record)
	r.primeRole(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateRolePayload{
		ClientMutationID: input.ClientMutationID,
		Role:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteRole(ctx context.Context, input graphql.DeleteRoleInput) (*graphql.DeleteRolePayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeRoleID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteRole(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Roles().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteRole(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Role", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteRolePayload{
		ClientMutationID: input.ClientMutationID,
		DeletedRoleID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) RoleCreated(ctx context.Context) (<-chan *graphql.Role, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Role, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Role)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) RoleUpdated(ctx context.Context) (<-chan *graphql.Role, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.Role, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.Role)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) RoleDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "Role", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *Resolver) loadTag(ctx context.Context, id string) (*gen.Tag, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Tags().ByID(ctx, id)
}

func (r *Resolver) primeTag(ctx context.Context, record *gen.Tag) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.Tag(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLTag(record *gen.Tag) *graphql.Tag {
	if record == nil {
		return nil
	}
	return &graphql.Tag{
		ID:          relay.ToGlobalID("Tag", record.ID),
		Name:        record.Name,
		Slug:        record.Slug,
		Description: record.Description,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeTagID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "Tag" {
		return "", fmt.Errorf("invalid id for Tag: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) Tag(ctx context.Context, id string) (*graphql.Tag, error) {
	nativeID, err := decodeTagID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadTag(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLTag(record), nil
}

func (r *queryResolver) Tags(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.TagConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Tags().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Tags().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.TagEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnTag(ctx, record); err != nil {
			return nil, err
		}
		r.primeTag(ctx, record)
		edges[idx] = &graphql.TagEdge{
			Cursor: cursor,
			Node:   toGraphQLTag(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.TagConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateTag(ctx context.Context, input graphql.CreateTagInput) (*graphql.CreateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.Tag)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateTag(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Tags().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateTag(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	return &graphql.CreateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateTag(ctx context.Context, input graphql.UpdateTagInput) (*graphql.UpdateTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.Tag{ID: nativeID}
	if input.Name != nil {
		model.Name = *input.Name
	}
	if input.Slug != nil {
		model.Slug = *input.Slug
	}
	if input.Description != nil {
		model.Description = input.Description
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateTag(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Tags().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateTag(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnTag(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLTag(record)
	r.primeTag(ctx, record)
	return &graphql.UpdateTagPayload{
		ClientMutationID: input.ClientMutationID,
		Tag:              gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteTag(ctx context.Context, input graphql.DeleteTagInput) (*graphql.DeleteTagPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeTagID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteTag(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Tags().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteTag(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("Tag", nativeID)
	return &graphql.DeleteTagPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedTagID:     deletedID,
	}, nil
}

func (r *Resolver) loadUser(ctx context.Context, id string) (*gen.User, error) {
	if r == nil || r.ORM == nil {
		return nil, nil
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			return loader.Load(ctx, id)
		}
	}
	return r.ORM.Users().ByID(ctx, id)
}

func (r *Resolver) primeUser(ctx context.Context, record *gen.User) {
	if record == nil {
		return
	}
	if loaders := dataloaders.FromContext(ctx); loaders != nil {
		if loader := loaders.User(); loader != nil {
			loader.Prime(record.ID, record)
		}
	}
}

func toGraphQLUser(record *gen.User) *graphql.User {
	if record == nil {
		return nil
	}
	return &graphql.User{
		ID:          relay.ToGlobalID("User", record.ID),
		Username:    record.Username,
		Email:       record.Email,
		Password:    record.Password,
		DisplayName: record.DisplayName,
		Bio:         record.Bio,
		AvatarURL:   record.AvatarURL,
		WebsiteURL:  record.WebsiteURL,
		LastLoginAt: record.LastLoginAt,
		CreatedAt:   record.CreatedAt,
		UpdatedAt:   record.UpdatedAt,
	}
}

func decodeUserID(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("id is required")
	}
	typ, nativeID, err := relay.FromGlobalID(id)
	if err != nil {
		return id, nil
	}
	if typ != "User" {
		return "", fmt.Errorf("invalid id for User: %s", typ)
	}
	return nativeID, nil
}

func (r *queryResolver) User(ctx context.Context, id string) (*graphql.User, error) {
	nativeID, err := decodeUserID(id)
	if err != nil {
		return nil, err
	}
	record, err := r.loadUser(ctx, nativeID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	return toGraphQLUser(record), nil
}

func (r *queryResolver) Users(ctx context.Context, first *int, after *string, last *int, before *string) (*graphql.UserConnection, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
		}
	}
	total, err := r.ORM.Users().Count(ctx)
	if err != nil {
		return nil, err
	}
	records, err := r.ORM.Users().List(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	edges := make([]*graphql.UserEdge, len(records))
	for idx, record := range records {
		cursor := encodeCursor(offset + idx)
		if err := r.applyBeforeReturnUser(ctx, record); err != nil {
			return nil, err
		}
		r.primeUser(ctx, record)
		edges[idx] = &graphql.UserEdge{
			Cursor: cursor,
			Node:   toGraphQLUser(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql.PageInfo{
		HasNextPage:     offset+len(edges) < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql.UserConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

func (r *mutationResolver) CreateUser(ctx context.Context, input graphql.CreateUserInput) (*graphql.CreateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	model := new(gen.User)
	if input.ID != nil {
		model.ID = *input.ID
	}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Password != nil {
		model.Password = *input.Password
	}
	if input.DisplayName != nil {
		model.DisplayName = input.DisplayName
	}
	if input.Bio != nil {
		model.Bio = input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarURL = input.AvatarURL
	}
	if input.WebsiteURL != nil {
		model.WebsiteURL = input.WebsiteURL
	}
	if input.LastLoginAt != nil {
		model.LastLoginAt = input.LastLoginAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeCreateUser(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Users().Create(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterCreateUser(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated, gqlRecord)
	return &graphql.CreateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) UpdateUser(ctx context.Context, input graphql.UpdateUserInput) (*graphql.UpdateUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	model := &gen.User{ID: nativeID}
	if input.Username != nil {
		model.Username = *input.Username
	}
	if input.Email != nil {
		model.Email = *input.Email
	}
	if input.Password != nil {
		model.Password = *input.Password
	}
	if input.DisplayName != nil {
		model.DisplayName = input.DisplayName
	}
	if input.Bio != nil {
		model.Bio = input.Bio
	}
	if input.AvatarURL != nil {
		model.AvatarURL = input.AvatarURL
	}
	if input.WebsiteURL != nil {
		model.WebsiteURL = input.WebsiteURL
	}
	if input.LastLoginAt != nil {
		model.LastLoginAt = input.LastLoginAt
	}
	if input.CreatedAt != nil {
		model.CreatedAt = *input.CreatedAt
	}
	if input.UpdatedAt != nil {
		model.UpdatedAt = *input.UpdatedAt
	}
	if err := r.applyBeforeUpdateUser(ctx, input, model); err != nil {
		return nil, err
	}
	record, err := r.ORM.Users().Update(ctx, model)
	if err != nil {
		return nil, err
	}
	if err := r.applyAfterUpdateUser(ctx, record); err != nil {
		return nil, err
	}
	if err := r.applyBeforeReturnUser(ctx, record); err != nil {
		return nil, err
	}
	gqlRecord := toGraphQLUser(record)
	r.primeUser(ctx, record)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated, gqlRecord)
	return &graphql.UpdateUserPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlRecord,
	}, nil
}

func (r *mutationResolver) DeleteUser(ctx context.Context, input graphql.DeleteUserInput) (*graphql.DeleteUserPayload, error) {
	if r.ORM == nil {
		return nil, fmt.Errorf("orm client is not configured")
	}
	nativeID, err := decodeUserID(input.ID)
	if err != nil {
		return nil, err
	}
	if err := r.applyBeforeDeleteUser(ctx, input, nativeID); err != nil {
		return nil, err
	}
	if err := r.ORM.Users().Delete(ctx, nativeID); err != nil {
		return nil, err
	}
	if err := r.applyAfterDeleteUser(ctx, input, nativeID); err != nil {
		return nil, err
	}
	deletedID := relay.ToGlobalID("User", nativeID)
	publishSubscriptionEvent(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted, deletedID)
	return &graphql.DeleteUserPayload{
		ClientMutationID: input.ClientMutationID,
		DeletedUserID:    deletedID,
	}, nil
}

func (r *subscriptionResolver) UserCreated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerCreated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *graphql.User, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerUpdated)
	if err != nil {
		return nil, err
	}
	out := make(chan *graphql.User, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				obj, ok := payload.(*graphql.User)
				if !ok || obj == nil {
					continue
				}
				select {
				case out <- obj:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func (r *subscriptionResolver) UserDeleted(ctx context.Context) (<-chan string, error) {
	stream, stop, err := subscribeToEntity(ctx, r.subscriptionBroker(), "User", SubscriptionTriggerDeleted)
	if err != nil {
		return nil, err
	}
	out := make(chan string, 1)
	go func() {
		defer close(out)
		if stop != nil {
			defer stop()
		}
		for {
			select {
			case <-ctx.Done():
				return
			case payload, ok := <-stream:
				if !ok {
					return
				}
				value, ok := payload.(string)
				if !ok || value == "" {
					continue
				}
				select {
				case out <- value:
					continue
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return out, nil
}

func toGraphQLEnum[T ~string](value string) T {
	return T(value)
}

func toGraphQLEnumPtr[T ~string](value *string) *T {
	if value == nil {
		return nil
	}
	out := T(*value)
	return &out
}

func fromGraphQLEnum[T ~string](value T) string {
	return string(value)
}

func fromGraphQLEnumPtr[T ~string](value *T) *string {
	if value == nil {
		return nil
	}
	out := string(*value)
	return &out
}

func toGraphQLIntPtr[T ~int16 | ~int32](input *T) *int {
	if input == nil {
		return nil
	}
	value := int(*input)
	return &value
}
