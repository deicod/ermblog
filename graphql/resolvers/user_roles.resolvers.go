package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"sort"

	graphql1 "github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/orm/gen"
)

// AssignUserRoles is the resolver for the assignUserRoles field.
func (r *mutationResolver) AssignUserRoles(ctx context.Context, input graphql1.AssignUserRolesInput) (*graphql1.AssignUserRolesPayload, error) {
	nativeUserID, err := decodeUserID(input.UserID)
	if err != nil {
		return nil, err
	}

	userClient := r.userClient()
	if userClient == nil {
		return nil, fmt.Errorf("user provider is not configured")
	}

	user, err := userClient.ByID(ctx, nativeUserID)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	roleIDs := make([]string, 0, len(input.RoleIDs))
	if len(input.RoleIDs) > 0 {
		roleClient := r.roleClient()
		if roleClient == nil {
			return nil, fmt.Errorf("role provider is not configured")
		}
		seen := make(map[string]struct{}, len(input.RoleIDs))
		for _, encoded := range input.RoleIDs {
			nativeRoleID, err := decodeRoleID(encoded)
			if err != nil {
				return nil, err
			}
			if _, ok := seen[nativeRoleID]; ok {
				continue
			}
			seen[nativeRoleID] = struct{}{}
			role, err := roleClient.ByID(ctx, nativeRoleID)
			if err != nil {
				return nil, err
			}
			if role == nil {
				return nil, fmt.Errorf("role not found")
			}
			roleIDs = append(roleIDs, nativeRoleID)
		}
	}

	service := r.userRoleService()
	if service == nil {
		return nil, fmt.Errorf("user role service is not configured")
	}
	if err := service.AssignUserRoles(ctx, nativeUserID, roleIDs); err != nil {
		return nil, err
	}

	refreshed, err := userClient.ByID(ctx, nativeUserID)
	if err != nil {
		return nil, err
	}
	if refreshed == nil {
		refreshed = user
	}
	if err := r.applyBeforeReturnUser(ctx, refreshed); err != nil {
		return nil, err
	}
	gqlUser := toGraphQLUser(refreshed)
	r.primeUser(ctx, refreshed)

	return &graphql1.AssignUserRolesPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlUser,
	}, nil
}

// RemoveUserRoles is the resolver for the removeUserRoles field.
func (r *mutationResolver) RemoveUserRoles(ctx context.Context, input graphql1.RemoveUserRolesInput) (*graphql1.RemoveUserRolesPayload, error) {
	nativeUserID, err := decodeUserID(input.UserID)
	if err != nil {
		return nil, err
	}

	userClient := r.userClient()
	if userClient == nil {
		return nil, fmt.Errorf("user provider is not configured")
	}

	user, err := userClient.ByID(ctx, nativeUserID)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	roleIDs := make([]string, 0, len(input.RoleIDs))
	if len(input.RoleIDs) > 0 {
		roleClient := r.roleClient()
		if roleClient == nil {
			return nil, fmt.Errorf("role provider is not configured")
		}
		seen := make(map[string]struct{}, len(input.RoleIDs))
		for _, encoded := range input.RoleIDs {
			nativeRoleID, err := decodeRoleID(encoded)
			if err != nil {
				return nil, err
			}
			if _, ok := seen[nativeRoleID]; ok {
				continue
			}
			seen[nativeRoleID] = struct{}{}
			role, err := roleClient.ByID(ctx, nativeRoleID)
			if err != nil {
				return nil, err
			}
			if role == nil {
				return nil, fmt.Errorf("role not found")
			}
			roleIDs = append(roleIDs, nativeRoleID)
		}
	}

	service := r.userRoleService()
	if service == nil {
		return nil, fmt.Errorf("user role service is not configured")
	}
	if err := service.RemoveUserRoles(ctx, nativeUserID, roleIDs); err != nil {
		return nil, err
	}

	refreshed, err := userClient.ByID(ctx, nativeUserID)
	if err != nil {
		return nil, err
	}
	if refreshed == nil {
		refreshed = user
	}
	if err := r.applyBeforeReturnUser(ctx, refreshed); err != nil {
		return nil, err
	}
	gqlUser := toGraphQLUser(refreshed)
	r.primeUser(ctx, refreshed)

	return &graphql1.RemoveUserRolesPayload{
		ClientMutationID: input.ClientMutationID,
		User:             gqlUser,
	}, nil
}

// Role_users is the resolver for the users field.
func (r *Resolver) Role_users(ctx context.Context, obj *graphql1.Role, first *int, after *string, last *int, before *string) (*graphql1.UserConnection, error) {
	if obj == nil {
		return &graphql1.UserConnection{
			Edges:      []*graphql1.UserEdge{},
			PageInfo:   &graphql1.PageInfo{HasNextPage: false, HasPreviousPage: false},
			TotalCount: 0,
		}, nil
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	nativeRoleID, err := decodeRoleID(obj.ID)
	if err != nil {
		return nil, err
	}
	service := r.userRoleService()
	if service == nil {
		return nil, fmt.Errorf("user role service is not configured")
	}
	users, err := service.ListUsersForRole(ctx, nativeRoleID)
	if err != nil {
		return nil, err
	}
	cleaned := make([]*gen.User, 0, len(users))
	for _, user := range users {
		if user != nil {
			cleaned = append(cleaned, user)
		}
	}
	sort.SliceStable(cleaned, func(i, j int) bool {
		left := cleaned[i]
		right := cleaned[j]
		switch {
		case left.Username == right.Username:
			return left.ID < right.ID
		default:
			return left.Username < right.Username
		}
	})

	total := len(cleaned)
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
			if offset < 0 {
				offset = 0
			}
		}
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	if offset > total {
		offset = total
	}
	end := offset + limit
	if end > total {
		end = total
	}
	slice := cleaned[offset:end]
	edges := make([]*graphql1.UserEdge, len(slice))
	for idx, record := range slice {
		if err := r.applyBeforeReturnUser(ctx, record); err != nil {
			return nil, err
		}
		r.primeUser(ctx, record)
		cursor := encodeCursor(offset + idx)
		edges[idx] = &graphql1.UserEdge{
			Cursor: cursor,
			Node:   toGraphQLUser(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql1.PageInfo{
		HasNextPage:     end < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql1.UserConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}

// User_roles is the resolver for the roles field.
func (r *Resolver) User_roles(ctx context.Context, obj *graphql1.User, first *int, after *string, last *int, before *string) (*graphql1.RoleConnection, error) {
	if obj == nil {
		return &graphql1.RoleConnection{
			Edges:      []*graphql1.RoleEdge{},
			PageInfo:   &graphql1.PageInfo{HasNextPage: false, HasPreviousPage: false},
			TotalCount: 0,
		}, nil
	}
	if last != nil || before != nil {
		return nil, fmt.Errorf("backward pagination is not supported")
	}
	nativeUserID, err := decodeUserID(obj.ID)
	if err != nil {
		return nil, err
	}
	service := r.userRoleService()
	if service == nil {
		return nil, fmt.Errorf("user role service is not configured")
	}
	roles, err := service.ListRolesForUser(ctx, nativeUserID)
	if err != nil {
		return nil, err
	}
	cleaned := make([]*gen.Role, 0, len(roles))
	for _, role := range roles {
		if role != nil {
			cleaned = append(cleaned, role)
		}
	}
	sort.SliceStable(cleaned, func(i, j int) bool {
		left := cleaned[i]
		right := cleaned[j]
		switch {
		case left.Name == right.Name:
			return left.ID < right.ID
		default:
			return left.Name < right.Name
		}
	})

	total := len(cleaned)
	offset := 0
	if after != nil && *after != "" {
		if decoded, err := decodeCursor(*after); err == nil {
			offset = decoded + 1
			if offset < 0 {
				offset = 0
			}
		}
	}
	limit := defaultPageSize
	if first != nil && *first > 0 {
		limit = *first
	}
	if offset > total {
		offset = total
	}
	end := offset + limit
	if end > total {
		end = total
	}
	slice := cleaned[offset:end]
	edges := make([]*graphql1.RoleEdge, len(slice))
	for idx, record := range slice {
		if err := r.applyBeforeReturnRole(ctx, record); err != nil {
			return nil, err
		}
		r.primeRole(ctx, record)
		cursor := encodeCursor(offset + idx)
		edges[idx] = &graphql1.RoleEdge{
			Cursor: cursor,
			Node:   toGraphQLRole(record),
		}
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}
	pageInfo := &graphql1.PageInfo{
		HasNextPage:     end < total,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	return &graphql1.RoleConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: total,
	}, nil
}
