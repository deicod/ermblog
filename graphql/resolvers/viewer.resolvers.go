package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"strings"

	graphql1 "github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/oidc"
	"github.com/deicod/ermblog/orm/gen"
)

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*graphql1.Viewer, error) {
	claims, ok := oidc.FromContext(ctx)
	if !ok {
		return nil, nil
	}

	subject := strings.TrimSpace(claims.Subject)
	if subject == "" {
		return nil, nil
	}

	profile := &graphql1.Viewer{ID: subject}

	var user *gen.User
	if client := r.userClient(); client != nil {
		fetched, err := client.ByID(ctx, subject)
		if err != nil {
			return nil, err
		}
		user = fetched
	}

	if user != nil {
		if id := strings.TrimSpace(user.ID); id != "" {
			profile.ID = id
		}
	}

	var displayCandidates []string
	var emailCandidates []string
	var avatarCandidates []string

	if user != nil {
		displayCandidates = append(displayCandidates, derefString(user.DisplayName), user.Username, user.Email)
		emailCandidates = append(emailCandidates, user.Email)
		avatarCandidates = append(avatarCandidates, derefString(user.AvatarURL))
	}

	displayCandidates = append(displayCandidates, claims.Name, claims.Username, claims.Email, claims.Subject)
	emailCandidates = append(emailCandidates, claims.Email)
	avatarCandidates = append(avatarCandidates, claimString(claims.Raw, "picture", "avatar", "avatar_url", "avatarURL"))

	profile.DisplayName = optionalString(firstNonEmpty(displayCandidates...))
	profile.Email = optionalString(firstNonEmpty(emailCandidates...))
	profile.AvatarURL = optionalString(firstNonEmpty(avatarCandidates...))

	return profile, nil
}

func firstNonEmpty(values ...string) string {
	for _, value := range values {
		trimmed := strings.TrimSpace(value)
		if trimmed != "" {
			return trimmed
		}
	}
	return ""
}

func optionalString(value string) *string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return nil
	}
	result := trimmed
	return &result
}

func derefString(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}

func claimString(raw map[string]any, keys ...string) string {
	if len(raw) == 0 {
		return ""
	}
	for _, key := range keys {
		if candidate, ok := raw[key]; ok {
			switch v := candidate.(type) {
			case string:
				trimmed := strings.TrimSpace(v)
				if trimmed != "" {
					return trimmed
				}
			}
		}
	}
	return ""
}
