package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	graphql1 "github.com/deicod/ermblog/graphql"
	"github.com/deicod/ermblog/oidc"
	"github.com/deicod/ermblog/orm/gen"
)

const notificationPreferenceOptionPrefix = "notification_preferences:"

var notificationCategoryOrder = []graphql1.NotificationCategory{
	graphql1.NotificationCategoryCommentCreated,
	graphql1.NotificationCategoryCommentUpdated,
	graphql1.NotificationCategoryCommentDeleted,
	graphql1.NotificationCategoryPostCreated,
	graphql1.NotificationCategoryPostUpdated,
	graphql1.NotificationCategoryPostDeleted,
}

var notificationCategorySet = map[graphql1.NotificationCategory]struct{}{
	graphql1.NotificationCategoryCommentCreated: {},
	graphql1.NotificationCategoryCommentUpdated: {},
	graphql1.NotificationCategoryCommentDeleted: {},
	graphql1.NotificationCategoryPostCreated:    {},
	graphql1.NotificationCategoryPostUpdated:    {},
	graphql1.NotificationCategoryPostDeleted:    {},
}

type storedNotificationPreferences struct {
	Preferences map[string]bool `json:"preferences"`
}

func preferenceOptionName(userID string) string {
	return notificationPreferenceOptionPrefix + userID
}

func isKnownNotificationCategory(category graphql1.NotificationCategory) bool {
	_, ok := notificationCategorySet[category]
	return ok
}

func mapToPreferenceEntries(values map[graphql1.NotificationCategory]bool) []*graphql1.NotificationPreference {
	entries := make([]*graphql1.NotificationPreference, 0, len(notificationCategoryOrder))
	for _, category := range notificationCategoryOrder {
		enabled := true
		if values != nil {
			if value, ok := values[category]; ok {
				enabled = value
			}
		}
		entries = append(entries, &graphql1.NotificationPreference{Category: category, Enabled: enabled})
	}
	return entries
}

func decodeStoredPreferences(raw json.RawMessage) map[graphql1.NotificationCategory]bool {
	if len(raw) == 0 {
		return nil
	}
	var stored storedNotificationPreferences
	if err := json.Unmarshal(raw, &stored); err != nil {
		return nil
	}
	if len(stored.Preferences) == 0 {
		return nil
	}
	result := make(map[graphql1.NotificationCategory]bool, len(stored.Preferences))
	for key, value := range stored.Preferences {
		category := graphql1.NotificationCategory(key)
		if !isKnownNotificationCategory(category) {
			continue
		}
		result[category] = value
	}
	return result
}

func normalisePreferenceInput(entries []*graphql1.NotificationPreferenceInput) map[graphql1.NotificationCategory]bool {
	preferences := make(map[graphql1.NotificationCategory]bool, len(notificationCategoryOrder))
	for _, category := range notificationCategoryOrder {
		preferences[category] = true
	}
	for _, entry := range entries {
		if entry == nil {
			continue
		}
		category := entry.Category
		if !isKnownNotificationCategory(category) {
			continue
		}
		preferences[category] = entry.Enabled
	}
	return preferences
}

func encodePreferences(preferences map[graphql1.NotificationCategory]bool) (json.RawMessage, error) {
	payload := storedNotificationPreferences{Preferences: make(map[string]bool, len(preferences))}
	for category, enabled := range preferences {
		if !isKnownNotificationCategory(category) {
			continue
		}
		payload.Preferences[string(category)] = enabled
	}
	data, err := json.Marshal(&payload)
	if err != nil {
		return nil, err
	}
	return json.RawMessage(data), nil
}

// UpdateNotificationPreferences is the resolver for the updateNotificationPreferences field.
func (r *mutationResolver) UpdateNotificationPreferences(ctx context.Context, input graphql1.UpdateNotificationPreferencesInput) (*graphql1.UpdateNotificationPreferencesPayload, error) {
	claims, ok := oidc.FromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID := strings.TrimSpace(claims.Subject)
	if userID == "" {
		return nil, fmt.Errorf("unauthorized")
	}
	repo := r.optionRepository()
	if repo == nil {
		return nil, fmt.Errorf("option repository is not configured")
	}
	normalized := normalisePreferenceInput(input.Preferences)
	encoded, err := encodePreferences(normalized)
	if err != nil {
		return nil, err
	}
	optionName := preferenceOptionName(userID)
	existing, err := r.findOptionByName(ctx, repo, optionName)
	if err != nil {
		return nil, err
	}
	if existing == nil {
		option := &gen.Option{
			Name:     optionName,
			Value:    encoded,
			Autoload: false,
		}
		if _, err := r.createOption(ctx, repo, option); err != nil {
			return nil, err
		}
	} else {
		model := &gen.Option{
			ID:       existing.ID,
			Name:     existing.Name,
			Value:    encoded,
			Autoload: existing.Autoload,
		}
		if _, err := r.updateOption(ctx, repo, model); err != nil {
			return nil, err
		}
	}
	preferences := &graphql1.NotificationPreferences{Entries: mapToPreferenceEntries(normalized)}
	payload := &graphql1.UpdateNotificationPreferencesPayload{
		ClientMutationID: input.ClientMutationID,
		Preferences:      preferences,
	}
	return payload, nil
}

// NotificationPreferences is the resolver for the notificationPreferences field.
func (r *queryResolver) NotificationPreferences(ctx context.Context) (*graphql1.NotificationPreferences, error) {
	claims, ok := oidc.FromContext(ctx)
	if !ok {
		return &graphql1.NotificationPreferences{Entries: mapToPreferenceEntries(nil)}, nil
	}
	userID := strings.TrimSpace(claims.Subject)
	if userID == "" {
		return &graphql1.NotificationPreferences{Entries: mapToPreferenceEntries(nil)}, nil
	}
	repo := r.optionRepository()
	var stored map[graphql1.NotificationCategory]bool
	if repo != nil {
		record, err := r.findOptionByName(ctx, repo, preferenceOptionName(userID))
		if err != nil {
			return nil, err
		}
		if record != nil {
			stored = decodeStoredPreferences(record.Value)
		}
	}
	return &graphql1.NotificationPreferences{Entries: mapToPreferenceEntries(stored)}, nil
}
