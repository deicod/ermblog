// Code generated by erm. DO NOT EDIT.
package gen

import (
	"context"
	"errors"
	"fmt"
	"github.com/deicod/erm/orm/id"
	"github.com/deicod/erm/orm/pg"
	"github.com/deicod/erm/orm/runtime"
	"github.com/deicod/erm/orm/runtime/cache"
	"github.com/deicod/erm/orm/runtime/validation"
	"github.com/jackc/pgx/v5"
	"strings"
	"time"
)

var ValidationRegistry = validation.NewRegistry()

type Client struct {
	db    *pg.DB
	cache cache.Store
}

func NewClient(db *pg.DB) *Client {
	return &Client{db: db, cache: cache.Nop()}
}

func (c *Client) UseCache(store cache.Store) {
	if c == nil {
		return
	}
	if store == nil {
		store = cache.Nop()
	}
	c.cache = store
}

func (c *Client) cacheStore() cache.Store {
	if c == nil || c.cache == nil {
		return cache.Nop()
	}
	return c.cache
}

func makeCacheKey(entity string, id any) string {
	return "orm:" + entity + ":" + fmt.Sprint(id)
}

func (c *Client) Categories() *CategoryClient {
	return &CategoryClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Comments() *CommentClient {
	return &CommentClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Posts() *PostClient {
	return &PostClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Tags() *TagClient {
	return &TagClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Users() *UserClient {
	return &UserClient{db: c.db, cache: c.cacheStore()}
}

const categoryInsertQuery = `INSERT INTO categories (id, name, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, slug, description, created_at, updated_at`
const categorySelectQuery = `SELECT id, name, slug, description, created_at, updated_at FROM categories WHERE id = $1`
const categoryListQuery = `SELECT id, name, slug, description, created_at, updated_at FROM categories ORDER BY id LIMIT $1 OFFSET $2`
const categoryUpdateQuery = `UPDATE categories SET name = $1, description = $2, updated_at = $3 WHERE id = $4 RETURNING id, name, slug, description, created_at, updated_at`
const categoryCountQuery = `SELECT COUNT(*) FROM categories`
const categoryDeleteQuery = `DELETE FROM categories WHERE id = $1`

type CategoryClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *CategoryClient) Create(ctx context.Context, input *Category) (*Category, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.Slug) {
		return nil, fmt.Errorf("Category.Slug is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Category", validation.OpCreate, categoryValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, categoryInsertQuery, input.ID, input.Name, input.Description, input.CreatedAt, input.UpdatedAt)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Category", out.ID), out)
	}
	return out, nil
}

func (c *CategoryClient) BulkCreate(ctx context.Context, inputs []*Category) ([]*Category, error) {
	if len(inputs) == 0 {
		return []*Category{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if !runtime.IsZeroValue(input.Slug) {
			return nil, fmt.Errorf("Category.Slug is computed and cannot be set")
		}
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Category", validation.OpCreate, categoryValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Name, input.Description, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "categories",
		Columns:   []string{"id", "name", "description", "created_at", "updated_at"},
		Returning: []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Category", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *CategoryClient) ByID(ctx context.Context, id string) (*Category, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Category", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Category); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, categorySelectQuery, id)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Category", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *CategoryClient) List(ctx context.Context, limit, offset int) ([]*Category, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, categoryListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *CategoryClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, categoryCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *CategoryClient) Update(ctx context.Context, input *Category) (*Category, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Category", validation.OpUpdate, categoryValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, categoryUpdateQuery, input.Name, input.Description, input.UpdatedAt, input.ID)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Category", out.ID), out)
	}
	return out, nil
}

func (c *CategoryClient) BulkUpdate(ctx context.Context, inputs []*Category) ([]*Category, error) {
	if len(inputs) == 0 {
		return []*Category{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Category", validation.OpUpdate, categoryValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Name, input.Description, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "categories",
		PrimaryColumn: "id",
		Columns:       []string{"name", "description", "updated_at"},
		Returning:     []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Category", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *CategoryClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, categoryDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Category", id))
	}
	return nil
}

func (c *CategoryClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "categories",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Category", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type CategoryQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{db: c.db, defaultLimit: 50, maxLimit: 250}
}

func (q *CategoryQuery) Limit(n int) *CategoryQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *CategoryQuery) Offset(n int) *CategoryQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *CategoryQuery) WhereIDEq(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CategoryQuery) WhereNameEq(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CategoryQuery) WhereNameILike(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *CategoryQuery) OrderByNameAsc() *CategoryQuery {
	q.orders = append(q.orders, runtime.Order{Column: "name", Direction: runtime.SortAsc})
	return q
}

func (q *CategoryQuery) OrderByCreatedAtDesc() *CategoryQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *CategoryQuery) All(ctx context.Context) ([]*Category, error) {
	spec := runtime.SelectSpec{
		Table:      "categories",
		Columns:    []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *CategoryQuery) Stream(ctx context.Context) (*runtime.Stream[*Category], error) {
	spec := runtime.SelectSpec{
		Table:      "categories",
		Columns:    []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Category](rows, func(rows pgx.Rows) (*Category, error) {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *CategoryQuery) First(ctx context.Context) (*Category, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *CategoryQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "categories",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *CategoryQuery) clone() *CategoryQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *CategoryQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const categoryPostsRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at FROM posts WHERE category_id IN (%s)`

func (c *CategoryClient) LoadPosts(ctx context.Context, parents ...*Category) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Category, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureCategoryEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureCategoryEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
		}
		return nil
	}
	sql, args := buildInQuery(categoryPostsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		var owner keyType
		ownerPtr := item.CategoryID
		if ownerPtr == nil {
			continue
		}
		owner = *ownerPtr
		if isZero(owner) {
			continue
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureCategoryEdges(parent)
			edges.Posts = append(edges.Posts, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCategoryEdges(parent)
		if edges.Posts == nil {
			edges.Posts = []*Post{}
		}
		edges.markLoaded("posts")
	}
	return nil
}

const commentInsertQuery = `INSERT INTO comments (id, post_id, author_id, parent_id, body, status, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, post_id, author_id, parent_id, body, status, created_at, updated_at`
const commentSelectQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments WHERE id = $1`
const commentListQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments ORDER BY id LIMIT $1 OFFSET $2`
const commentUpdateQuery = `UPDATE comments SET post_id = $1, author_id = $2, parent_id = $3, body = $4, status = $5, updated_at = $6 WHERE id = $7 RETURNING id, post_id, author_id, parent_id, body, status, created_at, updated_at`
const commentCountQuery = `SELECT COUNT(*) FROM comments`
const commentDeleteQuery = `DELETE FROM comments WHERE id = $1`

type CommentClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *CommentClient) Create(ctx context.Context, input *Comment) (*Comment, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpCreate, commentValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, commentInsertQuery, input.ID, input.PostID, input.AuthorID, input.ParentID, input.Body, input.Status, input.CreatedAt, input.UpdatedAt)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostID, &out.AuthorID, &out.ParentID, &out.Body, &out.Status, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Comment", out.ID), out)
	}
	return out, nil
}

func (c *CommentClient) BulkCreate(ctx context.Context, inputs []*Comment) ([]*Comment, error) {
	if len(inputs) == 0 {
		return []*Comment{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpCreate, commentValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.PostID, input.AuthorID, input.ParentID, input.Body, input.Status, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "comments",
		Columns:   []string{"id", "post_id", "author_id", "parent_id", "body", "status", "created_at", "updated_at"},
		Returning: []string{"id", "post_id", "author_id", "parent_id", "body", "status", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Comment", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *CommentClient) ByID(ctx context.Context, id string) (*Comment, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Comment", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Comment); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, commentSelectQuery, id)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostID, &out.AuthorID, &out.ParentID, &out.Body, &out.Status, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Comment", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *CommentClient) List(ctx context.Context, limit, offset int) ([]*Comment, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, commentListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *CommentClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, commentCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *CommentClient) Update(ctx context.Context, input *Comment) (*Comment, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpUpdate, commentValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, commentUpdateQuery, input.PostID, input.AuthorID, input.ParentID, input.Body, input.Status, input.UpdatedAt, input.ID)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostID, &out.AuthorID, &out.ParentID, &out.Body, &out.Status, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Comment", out.ID), out)
	}
	return out, nil
}

func (c *CommentClient) BulkUpdate(ctx context.Context, inputs []*Comment) ([]*Comment, error) {
	if len(inputs) == 0 {
		return []*Comment{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpUpdate, commentValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.PostID, input.AuthorID, input.ParentID, input.Body, input.Status, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "comments",
		PrimaryColumn: "id",
		Columns:       []string{"post_id", "author_id", "parent_id", "body", "status", "updated_at"},
		Returning:     []string{"id", "post_id", "author_id", "parent_id", "body", "status", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Comment", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *CommentClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, commentDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Comment", id))
	}
	return nil
}

func (c *CommentClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "comments",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Comment", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type CommentQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{db: c.db, defaultLimit: 50, maxLimit: 250}
}

func (q *CommentQuery) Limit(n int) *CommentQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *CommentQuery) Offset(n int) *CommentQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *CommentQuery) WhereIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WherePostIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "post_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WhereAuthorIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "author_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WhereStatusEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "status", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WhereCreatedAfter(value time.Time) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpGTE, Value: value})
	return q
}

func (q *CommentQuery) WhereCreatedBefore(value time.Time) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpLTE, Value: value})
	return q
}

func (q *CommentQuery) OrderByCreatedAtAsc() *CommentQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortAsc})
	return q
}

func (q *CommentQuery) OrderByCreatedAtDesc() *CommentQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *CommentQuery) All(ctx context.Context) ([]*Comment, error) {
	spec := runtime.SelectSpec{
		Table:      "comments",
		Columns:    []string{"id", "post_id", "author_id", "parent_id", "body", "status", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *CommentQuery) Stream(ctx context.Context) (*runtime.Stream[*Comment], error) {
	spec := runtime.SelectSpec{
		Table:      "comments",
		Columns:    []string{"id", "post_id", "author_id", "parent_id", "body", "status", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Comment](rows, func(rows pgx.Rows) (*Comment, error) {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *CommentQuery) First(ctx context.Context) (*Comment, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *CommentQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "comments",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *CommentQuery) clone() *CommentQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *CommentQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const commentPostRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at FROM posts WHERE id IN (%s)`

func (c *CommentClient) LoadPost(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("post")
		var fk keyType
		fk = parent.PostID
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentPostRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Post, len(keys))
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		var fk keyType
		fk = parent.PostID
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Post = item
		} else {
			edges.Post = nil
		}
	}
	return nil
}

const commentAuthorRelationQuery = `SELECT id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at FROM users WHERE id IN (%s)`

func (c *CommentClient) LoadAuthor(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("author")
		var fk keyType
		fk = parent.AuthorID
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentAuthorRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*User, len(keys))
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		var fk keyType
		fk = parent.AuthorID
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Author = item
		} else {
			edges.Author = nil
		}
	}
	return nil
}

const commentParentRelationQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments WHERE id IN (%s)`

func (c *CommentClient) LoadParent(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("parent")
		var fk keyType
		fkPtr := parent.ParentID
		if fkPtr == nil {
			edges.Parent = nil
			continue
		}
		fk = *fkPtr
		if isZero(fk) {
			edges.Parent = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentParentRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Comment, len(keys))
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		var fk keyType
		fkPtr := parent.ParentID
		if fkPtr == nil {
			edges.Parent = nil
			continue
		}
		fk = *fkPtr
		if isZero(fk) {
			edges.Parent = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Parent = item
		} else {
			edges.Parent = nil
		}
	}
	return nil
}

const commentRepliesRelationQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments WHERE parent_id IN (%s)`

func (c *CommentClient) LoadReplies(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Comment, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureCommentEdges(parent)
			if edges.Replies == nil {
				edges.Replies = []*Comment{}
			}
			edges.markLoaded("replies")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureCommentEdges(parent)
			if edges.Replies == nil {
				edges.Replies = []*Comment{}
			}
			edges.markLoaded("replies")
		}
		return nil
	}
	sql, args := buildInQuery(commentRepliesRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		var owner keyType
		ownerPtr := item.ParentID
		if ownerPtr == nil {
			continue
		}
		owner = *ownerPtr
		if isZero(owner) {
			continue
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureCommentEdges(parent)
			edges.Replies = append(edges.Replies, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		if edges.Replies == nil {
			edges.Replies = []*Comment{}
		}
		edges.markLoaded("replies")
	}
	return nil
}

const postInsertQuery = `INSERT INTO posts (id, author_id, category_id, title, excerpt, body, status, is_featured, published_at, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at`
const postSelectQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at FROM posts WHERE id = $1`
const postListQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at FROM posts ORDER BY id LIMIT $1 OFFSET $2`
const postUpdateQuery = `UPDATE posts SET author_id = $1, category_id = $2, title = $3, excerpt = $4, body = $5, status = $6, is_featured = $7, published_at = $8, updated_at = $9 WHERE id = $10 RETURNING id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at`
const postCountQuery = `SELECT COUNT(*) FROM posts`
const postDeleteQuery = `DELETE FROM posts WHERE id = $1`

type PostClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *PostClient) Create(ctx context.Context, input *Post) (*Post, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.Slug) {
		return nil, fmt.Errorf("Post.Slug is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Post", validation.OpCreate, postValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, postInsertQuery, input.ID, input.AuthorID, input.CategoryID, input.Title, input.Excerpt, input.Body, input.Status, input.IsFeatured, input.PublishedAt, input.CreatedAt, input.UpdatedAt)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorID, &out.CategoryID, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.Status, &out.IsFeatured, &out.PublishedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Post", out.ID), out)
	}
	return out, nil
}

func (c *PostClient) BulkCreate(ctx context.Context, inputs []*Post) ([]*Post, error) {
	if len(inputs) == 0 {
		return []*Post{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if !runtime.IsZeroValue(input.Slug) {
			return nil, fmt.Errorf("Post.Slug is computed and cannot be set")
		}
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Post", validation.OpCreate, postValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.AuthorID, input.CategoryID, input.Title, input.Excerpt, input.Body, input.Status, input.IsFeatured, input.PublishedAt, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "posts",
		Columns:   []string{"id", "author_id", "category_id", "title", "excerpt", "body", "status", "is_featured", "published_at", "created_at", "updated_at"},
		Returning: []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "status", "is_featured", "published_at", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Post", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *PostClient) ByID(ctx context.Context, id string) (*Post, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Post", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Post); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, postSelectQuery, id)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorID, &out.CategoryID, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.Status, &out.IsFeatured, &out.PublishedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Post", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *PostClient) List(ctx context.Context, limit, offset int) ([]*Post, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, postListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *PostClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, postCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *PostClient) Update(ctx context.Context, input *Post) (*Post, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Post", validation.OpUpdate, postValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, postUpdateQuery, input.AuthorID, input.CategoryID, input.Title, input.Excerpt, input.Body, input.Status, input.IsFeatured, input.PublishedAt, input.UpdatedAt, input.ID)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorID, &out.CategoryID, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.Status, &out.IsFeatured, &out.PublishedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Post", out.ID), out)
	}
	return out, nil
}

func (c *PostClient) BulkUpdate(ctx context.Context, inputs []*Post) ([]*Post, error) {
	if len(inputs) == 0 {
		return []*Post{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Post", validation.OpUpdate, postValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.AuthorID, input.CategoryID, input.Title, input.Excerpt, input.Body, input.Status, input.IsFeatured, input.PublishedAt, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "posts",
		PrimaryColumn: "id",
		Columns:       []string{"author_id", "category_id", "title", "excerpt", "body", "status", "is_featured", "published_at", "updated_at"},
		Returning:     []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "status", "is_featured", "published_at", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Post", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *PostClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, postDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Post", id))
	}
	return nil
}

func (c *PostClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "posts",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Post", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type PostQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *PostClient) Query() *PostQuery {
	return &PostQuery{db: c.db, defaultLimit: 25, maxLimit: 200}
}

func (q *PostQuery) Limit(n int) *PostQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *PostQuery) Offset(n int) *PostQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *PostQuery) WhereIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereAuthorIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "author_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereCategoryIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "category_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereStatusEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "status", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereTitleILike(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "title", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *PostQuery) WhereCreatedAfter(value time.Time) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpGTE, Value: value})
	return q
}

func (q *PostQuery) WhereCreatedBefore(value time.Time) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpLTE, Value: value})
	return q
}

func (q *PostQuery) OrderByCreatedAtDesc() *PostQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *PostQuery) OrderByPublishedAtDesc() *PostQuery {
	q.orders = append(q.orders, runtime.Order{Column: "published_at", Direction: runtime.SortDesc})
	return q
}

func (q *PostQuery) All(ctx context.Context) ([]*Post, error) {
	spec := runtime.SelectSpec{
		Table:      "posts",
		Columns:    []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "status", "is_featured", "published_at", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *PostQuery) Stream(ctx context.Context) (*runtime.Stream[*Post], error) {
	spec := runtime.SelectSpec{
		Table:      "posts",
		Columns:    []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "status", "is_featured", "published_at", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Post](rows, func(rows pgx.Rows) (*Post, error) {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *PostQuery) First(ctx context.Context) (*Post, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *PostQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "posts",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *PostQuery) clone() *PostQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *PostQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const postAuthorRelationQuery = `SELECT id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at FROM users WHERE id IN (%s)`

func (c *PostClient) LoadAuthor(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		edges.markLoaded("author")
		var fk keyType
		fk = parent.AuthorID
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(postAuthorRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*User, len(keys))
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		var fk keyType
		fk = parent.AuthorID
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Author = item
		} else {
			edges.Author = nil
		}
	}
	return nil
}

const postCategoryRelationQuery = `SELECT id, name, slug, description, created_at, updated_at FROM categories WHERE id IN (%s)`

func (c *PostClient) LoadCategory(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		edges.markLoaded("category")
		var fk keyType
		fkPtr := parent.CategoryID
		if fkPtr == nil {
			edges.Category = nil
			continue
		}
		fk = *fkPtr
		if isZero(fk) {
			edges.Category = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(postCategoryRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Category, len(keys))
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		var fk keyType
		fkPtr := parent.CategoryID
		if fkPtr == nil {
			edges.Category = nil
			continue
		}
		fk = *fkPtr
		if isZero(fk) {
			edges.Category = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Category = item
		} else {
			edges.Category = nil
		}
	}
	return nil
}

const postCommentsRelationQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments WHERE post_id IN (%s)`

func (c *PostClient) LoadComments(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Post, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensurePostEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensurePostEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
		}
		return nil
	}
	sql, args := buildInQuery(postCommentsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		var owner keyType
		owner = item.PostID
		if isZero(owner) {
			continue
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensurePostEdges(parent)
			edges.Comments = append(edges.Comments, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		if edges.Comments == nil {
			edges.Comments = []*Comment{}
		}
		edges.markLoaded("comments")
	}
	return nil
}

const postTagsRelationQuery = `SELECT id, name, slug, description, color, created_at, updated_at, jt.post_id FROM tags AS t JOIN post_tags AS jt ON t.id = jt.tag_id WHERE jt.post_id IN (%s)`

func (c *PostClient) LoadTags(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Post, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensurePostEdges(parent)
			if edges.Tags == nil {
				edges.Tags = []*Tag{}
			}
			edges.markLoaded("tags")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensurePostEdges(parent)
			if edges.Tags == nil {
				edges.Tags = []*Tag{}
			}
			edges.markLoaded("tags")
		}
		return nil
	}
	sql, args := buildInQuery(postTagsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Tag)
		var owner keyType
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt, &owner); err != nil {
			return err
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensurePostEdges(parent)
			edges.Tags = append(edges.Tags, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		if edges.Tags == nil {
			edges.Tags = []*Tag{}
		}
		edges.markLoaded("tags")
	}
	return nil
}

const tagInsertQuery = `INSERT INTO tags (id, name, description, color, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, slug, description, color, created_at, updated_at`
const tagSelectQuery = `SELECT id, name, slug, description, color, created_at, updated_at FROM tags WHERE id = $1`
const tagListQuery = `SELECT id, name, slug, description, color, created_at, updated_at FROM tags ORDER BY id LIMIT $1 OFFSET $2`
const tagUpdateQuery = `UPDATE tags SET name = $1, description = $2, color = $3, updated_at = $4 WHERE id = $5 RETURNING id, name, slug, description, color, created_at, updated_at`
const tagCountQuery = `SELECT COUNT(*) FROM tags`
const tagDeleteQuery = `DELETE FROM tags WHERE id = $1`

type TagClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *TagClient) Create(ctx context.Context, input *Tag) (*Tag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.Slug) {
		return nil, fmt.Errorf("Tag.Slug is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpCreate, tagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, tagInsertQuery, input.ID, input.Name, input.Description, input.Color, input.CreatedAt, input.UpdatedAt)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Tag", out.ID), out)
	}
	return out, nil
}

func (c *TagClient) BulkCreate(ctx context.Context, inputs []*Tag) ([]*Tag, error) {
	if len(inputs) == 0 {
		return []*Tag{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if !runtime.IsZeroValue(input.Slug) {
			return nil, fmt.Errorf("Tag.Slug is computed and cannot be set")
		}
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpCreate, tagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Name, input.Description, input.Color, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "tags",
		Columns:   []string{"id", "name", "description", "color", "created_at", "updated_at"},
		Returning: []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Tag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *TagClient) ByID(ctx context.Context, id string) (*Tag, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Tag", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Tag); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, tagSelectQuery, id)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Tag", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *TagClient) List(ctx context.Context, limit, offset int) ([]*Tag, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, tagListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *TagClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, tagCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *TagClient) Update(ctx context.Context, input *Tag) (*Tag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpUpdate, tagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, tagUpdateQuery, input.Name, input.Description, input.Color, input.UpdatedAt, input.ID)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Tag", out.ID), out)
	}
	return out, nil
}

func (c *TagClient) BulkUpdate(ctx context.Context, inputs []*Tag) ([]*Tag, error) {
	if len(inputs) == 0 {
		return []*Tag{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpUpdate, tagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Name, input.Description, input.Color, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "tags",
		PrimaryColumn: "id",
		Columns:       []string{"name", "description", "color", "updated_at"},
		Returning:     []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Tag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *TagClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, tagDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Tag", id))
	}
	return nil
}

func (c *TagClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "tags",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Tag", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type TagQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *TagClient) Query() *TagQuery {
	return &TagQuery{db: c.db, defaultLimit: 50, maxLimit: 250}
}

func (q *TagQuery) Limit(n int) *TagQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *TagQuery) Offset(n int) *TagQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *TagQuery) WhereIDEq(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *TagQuery) WhereNameEq(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *TagQuery) WhereNameILike(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *TagQuery) OrderByNameAsc() *TagQuery {
	q.orders = append(q.orders, runtime.Order{Column: "name", Direction: runtime.SortAsc})
	return q
}

func (q *TagQuery) OrderByCreatedAtDesc() *TagQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *TagQuery) All(ctx context.Context) ([]*Tag, error) {
	spec := runtime.SelectSpec{
		Table:      "tags",
		Columns:    []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *TagQuery) Stream(ctx context.Context) (*runtime.Stream[*Tag], error) {
	spec := runtime.SelectSpec{
		Table:      "tags",
		Columns:    []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Tag](rows, func(rows pgx.Rows) (*Tag, error) {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *TagQuery) First(ctx context.Context) (*Tag, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *TagQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "tags",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *TagQuery) clone() *TagQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *TagQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const tagPostsRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at, jt.tag_id FROM posts AS t JOIN post_tags AS jt ON t.id = jt.post_id WHERE jt.tag_id IN (%s)`

func (c *TagClient) LoadPosts(ctx context.Context, parents ...*Tag) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Tag, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureTagEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureTagEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
		}
		return nil
	}
	sql, args := buildInQuery(tagPostsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Post)
		var owner keyType
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt, &owner); err != nil {
			return err
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureTagEdges(parent)
			edges.Posts = append(edges.Posts, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureTagEdges(parent)
		if edges.Posts == nil {
			edges.Posts = []*Post{}
		}
		edges.markLoaded("posts")
	}
	return nil
}

const userInsertQuery = `INSERT INTO users (id, username, email, display_name, bio, avatar_url, role, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at`
const userSelectQuery = `SELECT id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at FROM users WHERE id = $1`
const userListQuery = `SELECT id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at FROM users ORDER BY id LIMIT $1 OFFSET $2`
const userUpdateQuery = `UPDATE users SET username = $1, email = $2, display_name = $3, bio = $4, avatar_url = $5, role = $6, updated_at = $7 WHERE id = $8 RETURNING id, username, email, slug, display_name, bio, avatar_url, role, created_at, updated_at`
const userCountQuery = `SELECT COUNT(*) FROM users`
const userDeleteQuery = `DELETE FROM users WHERE id = $1`

type UserClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *UserClient) Create(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.Slug) {
		return nil, fmt.Errorf("User.Slug is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, userInsertQuery, input.ID, input.Username, input.Email, input.DisplayName, input.Bio, input.AvatarURL, input.Role, input.CreatedAt, input.UpdatedAt)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Slug, &out.DisplayName, &out.Bio, &out.AvatarURL, &out.Role, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkCreate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if !runtime.IsZeroValue(input.Slug) {
			return nil, fmt.Errorf("User.Slug is computed and cannot be set")
		}
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Username, input.Email, input.DisplayName, input.Bio, input.AvatarURL, input.Role, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "users",
		Columns:   []string{"id", "username", "email", "display_name", "bio", "avatar_url", "role", "created_at", "updated_at"},
		Returning: []string{"id", "username", "email", "slug", "display_name", "bio", "avatar_url", "role", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *UserClient) ByID(ctx context.Context, id string) (*User, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("User", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*User); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, userSelectQuery, id)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Slug, &out.DisplayName, &out.Bio, &out.AvatarURL, &out.Role, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("User", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *UserClient) List(ctx context.Context, limit, offset int) ([]*User, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, userListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *UserClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, userCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *UserClient) Update(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, userUpdateQuery, input.Username, input.Email, input.DisplayName, input.Bio, input.AvatarURL, input.Role, input.UpdatedAt, input.ID)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Slug, &out.DisplayName, &out.Bio, &out.AvatarURL, &out.Role, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkUpdate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Username, input.Email, input.DisplayName, input.Bio, input.AvatarURL, input.Role, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "users",
		PrimaryColumn: "id",
		Columns:       []string{"username", "email", "display_name", "bio", "avatar_url", "role", "updated_at"},
		Returning:     []string{"id", "username", "email", "slug", "display_name", "bio", "avatar_url", "role", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *UserClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, userDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("User", id))
	}
	return nil
}

func (c *UserClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "users",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("User", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type UserQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *UserClient) Query() *UserQuery {
	return &UserQuery{db: c.db, defaultLimit: 50, maxLimit: 250}
}

func (q *UserQuery) Limit(n int) *UserQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *UserQuery) Offset(n int) *UserQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *UserQuery) WhereIDEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) WhereUsernameEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "username", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) WhereUsernameILike(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "username", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *UserQuery) WhereEmailILike(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "email", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *UserQuery) WhereRoleEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "role", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) WhereCreatedAfter(value time.Time) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpGTE, Value: value})
	return q
}

func (q *UserQuery) WhereCreatedBefore(value time.Time) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "created_at", Operator: runtime.OpLTE, Value: value})
	return q
}

func (q *UserQuery) OrderByCreatedAtDesc() *UserQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *UserQuery) OrderByUsernameAsc() *UserQuery {
	q.orders = append(q.orders, runtime.Order{Column: "username", Direction: runtime.SortAsc})
	return q
}

func (q *UserQuery) All(ctx context.Context) ([]*User, error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "username", "email", "slug", "display_name", "bio", "avatar_url", "role", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *UserQuery) Stream(ctx context.Context) (*runtime.Stream[*User], error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "username", "email", "slug", "display_name", "bio", "avatar_url", "role", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*User](rows, func(rows pgx.Rows) (*User, error) {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Slug, &item.DisplayName, &item.Bio, &item.AvatarURL, &item.Role, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *UserQuery) First(ctx context.Context) (*User, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *UserQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "users",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *UserQuery) clone() *UserQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *UserQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const userPostsRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, status, is_featured, published_at, created_at, updated_at FROM posts WHERE author_id IN (%s)`

func (c *UserClient) LoadPosts(ctx context.Context, parents ...*User) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*User, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureUserEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureUserEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
		}
		return nil
	}
	sql, args := buildInQuery(userPostsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorID, &item.CategoryID, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.Status, &item.IsFeatured, &item.PublishedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		var owner keyType
		owner = item.AuthorID
		if isZero(owner) {
			continue
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureUserEdges(parent)
			edges.Posts = append(edges.Posts, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureUserEdges(parent)
		if edges.Posts == nil {
			edges.Posts = []*Post{}
		}
		edges.markLoaded("posts")
	}
	return nil
}

const userCommentsRelationQuery = `SELECT id, post_id, author_id, parent_id, body, status, created_at, updated_at FROM comments WHERE author_id IN (%s)`

func (c *UserClient) LoadComments(ctx context.Context, parents ...*User) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*User, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureUserEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureUserEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
		}
		return nil
	}
	sql, args := buildInQuery(userCommentsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostID, &item.AuthorID, &item.ParentID, &item.Body, &item.Status, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		var owner keyType
		owner = item.AuthorID
		if isZero(owner) {
			continue
		}
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureUserEdges(parent)
			edges.Comments = append(edges.Comments, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureUserEdges(parent)
		if edges.Comments == nil {
			edges.Comments = []*Comment{}
		}
		edges.markLoaded("comments")
	}
	return nil
}

func categoryValidationRecord(input *Category) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"Name":        input.Name,
		"Description": input.Description,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func commentValidationRecord(input *Comment) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":        input.ID,
		"PostID":    input.PostID,
		"AuthorID":  input.AuthorID,
		"ParentID":  input.ParentID,
		"Body":      input.Body,
		"Status":    input.Status,
		"CreatedAt": input.CreatedAt,
		"UpdatedAt": input.UpdatedAt,
	}
}

func postValidationRecord(input *Post) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"AuthorID":    input.AuthorID,
		"CategoryID":  input.CategoryID,
		"Title":       input.Title,
		"Excerpt":     input.Excerpt,
		"Body":        input.Body,
		"Status":      input.Status,
		"IsFeatured":  input.IsFeatured,
		"PublishedAt": input.PublishedAt,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func tagValidationRecord(input *Tag) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"Name":        input.Name,
		"Description": input.Description,
		"Color":       input.Color,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func userValidationRecord(input *User) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"Username":    input.Username,
		"Email":       input.Email,
		"DisplayName": input.DisplayName,
		"Bio":         input.Bio,
		"AvatarURL":   input.AvatarURL,
		"Role":        input.Role,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func buildInQuery[T any](base string, values []T) (string, []any) {
	if len(values) == 0 {
		return base, nil
	}
	placeholders := make([]string, len(values))
	args := make([]any, len(values))
	for i := range values {
		placeholders[i] = fmt.Sprintf("$%d", i+1)
		args[i] = values[i]
	}
	return fmt.Sprintf(base, strings.Join(placeholders, ", ")), args
}

func isZero[T comparable](v T) bool {
	var zero T
	return v == zero
}
