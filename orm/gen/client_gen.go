// Code generated by erm. DO NOT EDIT.
package gen

import (
	"context"
	"errors"
	"fmt"
	"github.com/deicod/erm/orm/id"
	"github.com/deicod/erm/orm/pg"
	"github.com/deicod/erm/orm/runtime"
	"github.com/deicod/erm/orm/runtime/cache"
	"github.com/deicod/erm/orm/runtime/validation"
	"github.com/jackc/pgx/v5"
	"strings"
	"time"
)

var ValidationRegistry = validation.NewRegistry()

type Client struct {
	db    *pg.DB
	cache cache.Store
}

func NewClient(db *pg.DB) *Client {
	return &Client{db: db, cache: cache.Nop()}
}

func (c *Client) UseCache(store cache.Store) {
	if c == nil {
		return
	}
	if store == nil {
		store = cache.Nop()
	}
	c.cache = store
}

func (c *Client) cacheStore() cache.Store {
	if c == nil || c.cache == nil {
		return cache.Nop()
	}
	return c.cache
}

func makeCacheKey(entity string, id any) string {
	return "orm:" + entity + ":" + fmt.Sprint(id)
}

func (c *Client) Categories() *CategoryClient {
	return &CategoryClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Comments() *CommentClient {
	return &CommentClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Posts() *PostClient {
	return &PostClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) PostTags() *PostTagClient {
	return &PostTagClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Tags() *TagClient {
	return &TagClient{db: c.db, cache: c.cacheStore()}
}

func (c *Client) Users() *UserClient {
	return &UserClient{db: c.db, cache: c.cacheStore()}
}

const categoryInsertQuery = `INSERT INTO categories (id, name, slug, description, color, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, name, slug, description, color, created_at, updated_at`
const categorySelectQuery = `SELECT id, name, slug, description, color, created_at, updated_at FROM categories WHERE id = $1`
const categoryListQuery = `SELECT id, name, slug, description, color, created_at, updated_at FROM categories ORDER BY id LIMIT $1 OFFSET $2`
const categoryUpdateQuery = `UPDATE categories SET name = $1, slug = $2, description = $3, color = $4, updated_at = $5 WHERE id = $6 RETURNING id, name, slug, description, color, created_at, updated_at`
const categoryCountQuery = `SELECT COUNT(*) FROM categories`
const categoryDeleteQuery = `DELETE FROM categories WHERE id = $1`

type CategoryClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *CategoryClient) Create(ctx context.Context, input *Category) (*Category, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Category", validation.OpCreate, categoryValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, categoryInsertQuery, input.ID, input.Name, input.Slug, input.Description, input.Color, input.CreatedAt, input.UpdatedAt)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Category", out.ID), out)
	}
	return out, nil
}

func (c *CategoryClient) BulkCreate(ctx context.Context, inputs []*Category) ([]*Category, error) {
	if len(inputs) == 0 {
		return []*Category{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Category", validation.OpCreate, categoryValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Name, input.Slug, input.Description, input.Color, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "categories",
		Columns:   []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Returning: []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Category", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *CategoryClient) ByID(ctx context.Context, id string) (*Category, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Category", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Category); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, categorySelectQuery, id)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Category", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *CategoryClient) List(ctx context.Context, limit, offset int) ([]*Category, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, categoryListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *CategoryClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, categoryCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *CategoryClient) Update(ctx context.Context, input *Category) (*Category, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Category", validation.OpUpdate, categoryValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, categoryUpdateQuery, input.Name, input.Slug, input.Description, input.Color, input.UpdatedAt, input.ID)
	out := new(Category)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.Color, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Category", out.ID), out)
	}
	return out, nil
}

func (c *CategoryClient) BulkUpdate(ctx context.Context, inputs []*Category) ([]*Category, error) {
	if len(inputs) == 0 {
		return []*Category{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Category", validation.OpUpdate, categoryValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Name, input.Slug, input.Description, input.Color, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "categories",
		PrimaryColumn: "id",
		Columns:       []string{"name", "slug", "description", "color", "updated_at"},
		Returning:     []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Category", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *CategoryClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, categoryDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Category", id))
	}
	return nil
}

func (c *CategoryClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "categories",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Category", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type CategoryQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{db: c.db, defaultLimit: 20, maxLimit: 0}
}

func (q *CategoryQuery) Limit(n int) *CategoryQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *CategoryQuery) Offset(n int) *CategoryQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *CategoryQuery) WhereIDEq(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CategoryQuery) WhereSlugEq(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "slug", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CategoryQuery) WhereNameILike(value string) *CategoryQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *CategoryQuery) OrderByCreatedAtDesc() *CategoryQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *CategoryQuery) OrderByNameAsc() *CategoryQuery {
	q.orders = append(q.orders, runtime.Order{Column: "name", Direction: runtime.SortAsc})
	return q
}

func (q *CategoryQuery) All(ctx context.Context) ([]*Category, error) {
	spec := runtime.SelectSpec{
		Table:      "categories",
		Columns:    []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Category
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *CategoryQuery) Stream(ctx context.Context) (*runtime.Stream[*Category], error) {
	spec := runtime.SelectSpec{
		Table:      "categories",
		Columns:    []string{"id", "name", "slug", "description", "color", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Category](rows, func(rows pgx.Rows) (*Category, error) {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *CategoryQuery) First(ctx context.Context) (*Category, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *CategoryQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "categories",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *CategoryQuery) clone() *CategoryQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *CategoryQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const categoryPostsRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts WHERE category_id IN (%s)`

func (c *CategoryClient) LoadPosts(ctx context.Context, parents ...*Category) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*Category, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureCategoryEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureCategoryEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
		}
		return nil
	}
	sql, args := buildInQuery(categoryPostsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		owner := item.CategoryId
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureCategoryEdges(parent)
			edges.Posts = append(edges.Posts, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCategoryEdges(parent)
		if edges.Posts == nil {
			edges.Posts = []*Post{}
		}
		edges.markLoaded("posts")
	}
	return nil
}

const commentInsertQuery = `INSERT INTO comments (id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at`
const commentSelectQuery = `SELECT id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at FROM comments WHERE id = $1`
const commentListQuery = `SELECT id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at FROM comments ORDER BY id LIMIT $1 OFFSET $2`
const commentUpdateQuery = `UPDATE comments SET post_id = $1, author_id = $2, parent_id = $3, body = $4, is_edited = $5, updated_at = $6 WHERE id = $7 RETURNING id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at`
const commentCountQuery = `SELECT COUNT(*) FROM comments`
const commentDeleteQuery = `DELETE FROM comments WHERE id = $1`

type CommentClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *CommentClient) Create(ctx context.Context, input *Comment) (*Comment, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpCreate, commentValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, commentInsertQuery, input.ID, input.PostId, input.AuthorId, input.ParentId, input.Body, input.IsEdited, input.CreatedAt, input.UpdatedAt)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostId, &out.AuthorId, &out.ParentId, &out.Body, &out.IsEdited, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Comment", out.ID), out)
	}
	return out, nil
}

func (c *CommentClient) BulkCreate(ctx context.Context, inputs []*Comment) ([]*Comment, error) {
	if len(inputs) == 0 {
		return []*Comment{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpCreate, commentValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.PostId, input.AuthorId, input.ParentId, input.Body, input.IsEdited, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "comments",
		Columns:   []string{"id", "post_id", "author_id", "parent_id", "body", "is_edited", "created_at", "updated_at"},
		Returning: []string{"id", "post_id", "author_id", "parent_id", "body", "is_edited", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Comment", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *CommentClient) ByID(ctx context.Context, id string) (*Comment, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Comment", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Comment); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, commentSelectQuery, id)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostId, &out.AuthorId, &out.ParentId, &out.Body, &out.IsEdited, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Comment", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *CommentClient) List(ctx context.Context, limit, offset int) ([]*Comment, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, commentListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *CommentClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, commentCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *CommentClient) Update(ctx context.Context, input *Comment) (*Comment, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpUpdate, commentValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, commentUpdateQuery, input.PostId, input.AuthorId, input.ParentId, input.Body, input.IsEdited, input.UpdatedAt, input.ID)
	out := new(Comment)
	if err := row.Scan(&out.ID, &out.PostId, &out.AuthorId, &out.ParentId, &out.Body, &out.IsEdited, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Comment", out.ID), out)
	}
	return out, nil
}

func (c *CommentClient) BulkUpdate(ctx context.Context, inputs []*Comment) ([]*Comment, error) {
	if len(inputs) == 0 {
		return []*Comment{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Comment", validation.OpUpdate, commentValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.PostId, input.AuthorId, input.ParentId, input.Body, input.IsEdited, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "comments",
		PrimaryColumn: "id",
		Columns:       []string{"post_id", "author_id", "parent_id", "body", "is_edited", "updated_at"},
		Returning:     []string{"id", "post_id", "author_id", "parent_id", "body", "is_edited", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Comment", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *CommentClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, commentDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Comment", id))
	}
	return nil
}

func (c *CommentClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "comments",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Comment", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type CommentQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{db: c.db, defaultLimit: 50, maxLimit: 500}
}

func (q *CommentQuery) Limit(n int) *CommentQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *CommentQuery) Offset(n int) *CommentQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *CommentQuery) WhereIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WherePostIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "post_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WhereAuthorIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "author_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) WhereParentIDEq(value string) *CommentQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "parent_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *CommentQuery) OrderByCreatedAtAsc() *CommentQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortAsc})
	return q
}

func (q *CommentQuery) All(ctx context.Context) ([]*Comment, error) {
	spec := runtime.SelectSpec{
		Table:      "comments",
		Columns:    []string{"id", "post_id", "author_id", "parent_id", "body", "is_edited", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Comment
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *CommentQuery) Stream(ctx context.Context) (*runtime.Stream[*Comment], error) {
	spec := runtime.SelectSpec{
		Table:      "comments",
		Columns:    []string{"id", "post_id", "author_id", "parent_id", "body", "is_edited", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Comment](rows, func(rows pgx.Rows) (*Comment, error) {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *CommentQuery) First(ctx context.Context) (*Comment, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *CommentQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "comments",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *CommentQuery) clone() *CommentQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *CommentQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const commentPostRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts WHERE id IN (%s)`

func (c *CommentClient) LoadPost(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("post")
		fk := parent.PostId
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentPostRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Post, len(keys))
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.PostId
		edges := ensureCommentEdges(parent)
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Post = item
		} else {
			edges.Post = nil
		}
	}
	return nil
}

const commentAuthorRelationQuery = `SELECT id, username, email, name, bio, avatar_url, display_name, created_at, updated_at FROM users WHERE id IN (%s)`

func (c *CommentClient) LoadAuthor(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("author")
		fk := parent.AuthorId
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentAuthorRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*User, len(keys))
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.AuthorId
		edges := ensureCommentEdges(parent)
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Author = item
		} else {
			edges.Author = nil
		}
	}
	return nil
}

const commentParentRelationQuery = `SELECT id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at FROM comments WHERE id IN (%s)`

func (c *CommentClient) LoadParent(ctx context.Context, parents ...*Comment) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureCommentEdges(parent)
		edges.markLoaded("parent")
		fk := parent.ParentId
		if isZero(fk) {
			edges.Parent = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(commentParentRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Comment, len(keys))
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.ParentId
		edges := ensureCommentEdges(parent)
		if isZero(fk) {
			edges.Parent = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Parent = item
		} else {
			edges.Parent = nil
		}
	}
	return nil
}

const postInsertQuery = `INSERT INTO posts (id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at`
const postSelectQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts WHERE id = $1`
const postListQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts ORDER BY id LIMIT $1 OFFSET $2`
const postUpdateQuery = `UPDATE posts SET author_id = $1, category_id = $2, title = $3, slug = $4, excerpt = $5, body = $6, published_at = $7, is_published = $8, updated_at = $9 WHERE id = $10 RETURNING id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at`
const postCountQuery = `SELECT COUNT(*) FROM posts`
const postDeleteQuery = `DELETE FROM posts WHERE id = $1`

type PostClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *PostClient) Create(ctx context.Context, input *Post) (*Post, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Post", validation.OpCreate, postValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, postInsertQuery, input.ID, input.AuthorId, input.CategoryId, input.Title, input.Slug, input.Excerpt, input.Body, input.PublishedAt, input.IsPublished, input.CreatedAt, input.UpdatedAt)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorId, &out.CategoryId, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.PublishedAt, &out.IsPublished, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Post", out.ID), out)
	}
	return out, nil
}

func (c *PostClient) BulkCreate(ctx context.Context, inputs []*Post) ([]*Post, error) {
	if len(inputs) == 0 {
		return []*Post{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Post", validation.OpCreate, postValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.AuthorId, input.CategoryId, input.Title, input.Slug, input.Excerpt, input.Body, input.PublishedAt, input.IsPublished, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "posts",
		Columns:   []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "created_at", "updated_at"},
		Returning: []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Post", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *PostClient) ByID(ctx context.Context, id string) (*Post, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Post", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Post); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, postSelectQuery, id)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorId, &out.CategoryId, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.PublishedAt, &out.IsPublished, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Post", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *PostClient) List(ctx context.Context, limit, offset int) ([]*Post, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, postListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *PostClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, postCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *PostClient) Update(ctx context.Context, input *Post) (*Post, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Post", validation.OpUpdate, postValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, postUpdateQuery, input.AuthorId, input.CategoryId, input.Title, input.Slug, input.Excerpt, input.Body, input.PublishedAt, input.IsPublished, input.UpdatedAt, input.ID)
	out := new(Post)
	if err := row.Scan(&out.ID, &out.AuthorId, &out.CategoryId, &out.Title, &out.Slug, &out.Excerpt, &out.Body, &out.PublishedAt, &out.IsPublished, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Post", out.ID), out)
	}
	return out, nil
}

func (c *PostClient) BulkUpdate(ctx context.Context, inputs []*Post) ([]*Post, error) {
	if len(inputs) == 0 {
		return []*Post{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Post", validation.OpUpdate, postValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.AuthorId, input.CategoryId, input.Title, input.Slug, input.Excerpt, input.Body, input.PublishedAt, input.IsPublished, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "posts",
		PrimaryColumn: "id",
		Columns:       []string{"author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "updated_at"},
		Returning:     []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Post", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *PostClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, postDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Post", id))
	}
	return nil
}

func (c *PostClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "posts",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Post", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type PostQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *PostClient) Query() *PostQuery {
	return &PostQuery{db: c.db, defaultLimit: 20, maxLimit: 200}
}

func (q *PostQuery) Limit(n int) *PostQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *PostQuery) Offset(n int) *PostQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *PostQuery) WhereIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereAuthorIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "author_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereSlugEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "slug", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereIsPublishedEq(value bool) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "is_published", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) WhereCategoryIDEq(value string) *PostQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "category_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostQuery) OrderByPublishedAtDesc() *PostQuery {
	q.orders = append(q.orders, runtime.Order{Column: "published_at", Direction: runtime.SortDesc})
	return q
}

func (q *PostQuery) OrderByCreatedAtDesc() *PostQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *PostQuery) All(ctx context.Context) ([]*Post, error) {
	spec := runtime.SelectSpec{
		Table:      "posts",
		Columns:    []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Post
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *PostQuery) Stream(ctx context.Context) (*runtime.Stream[*Post], error) {
	spec := runtime.SelectSpec{
		Table:      "posts",
		Columns:    []string{"id", "author_id", "category_id", "title", "slug", "excerpt", "body", "published_at", "is_published", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Post](rows, func(rows pgx.Rows) (*Post, error) {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *PostQuery) First(ctx context.Context) (*Post, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *PostQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "posts",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *PostQuery) clone() *PostQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *PostQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const postAuthorRelationQuery = `SELECT id, username, email, name, bio, avatar_url, display_name, created_at, updated_at FROM users WHERE id IN (%s)`

func (c *PostClient) LoadAuthor(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		edges.markLoaded("author")
		fk := parent.AuthorId
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(postAuthorRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*User, len(keys))
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.AuthorId
		edges := ensurePostEdges(parent)
		if isZero(fk) {
			edges.Author = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Author = item
		} else {
			edges.Author = nil
		}
	}
	return nil
}

const postCategoryRelationQuery = `SELECT id, name, slug, description, color, created_at, updated_at FROM categories WHERE id IN (%s)`

func (c *PostClient) LoadCategory(ctx context.Context, parents ...*Post) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostEdges(parent)
		edges.markLoaded("category")
		fk := parent.CategoryId
		if isZero(fk) {
			edges.Category = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(postCategoryRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Category, len(keys))
	for rows.Next() {
		item := new(Category)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.Color, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.CategoryId
		edges := ensurePostEdges(parent)
		if isZero(fk) {
			edges.Category = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Category = item
		} else {
			edges.Category = nil
		}
	}
	return nil
}

const posttagInsertQuery = `INSERT INTO post_tags (id, post_id, tag_id, assigned_at, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, post_id, tag_id, assigned_at, created_at, updated_at`
const posttagSelectQuery = `SELECT id, post_id, tag_id, assigned_at, created_at, updated_at FROM post_tags WHERE id = $1`
const posttagListQuery = `SELECT id, post_id, tag_id, assigned_at, created_at, updated_at FROM post_tags ORDER BY id LIMIT $1 OFFSET $2`
const posttagUpdateQuery = `UPDATE post_tags SET post_id = $1, tag_id = $2, updated_at = $3 WHERE id = $4 RETURNING id, post_id, tag_id, assigned_at, created_at, updated_at`
const posttagCountQuery = `SELECT COUNT(*) FROM post_tags`
const posttagDeleteQuery = `DELETE FROM post_tags WHERE id = $1`

type PostTagClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *PostTagClient) Create(ctx context.Context, input *PostTag) (*PostTag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.AssignedAt.IsZero() {
		input.AssignedAt = now
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "PostTag", validation.OpCreate, posttagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, posttagInsertQuery, input.ID, input.PostId, input.TagId, input.AssignedAt, input.CreatedAt, input.UpdatedAt)
	out := new(PostTag)
	if err := row.Scan(&out.ID, &out.PostId, &out.TagId, &out.AssignedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("PostTag", out.ID), out)
	}
	return out, nil
}

func (c *PostTagClient) BulkCreate(ctx context.Context, inputs []*PostTag) ([]*PostTag, error) {
	if len(inputs) == 0 {
		return []*PostTag{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.AssignedAt.IsZero() {
			input.AssignedAt = now
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "PostTag", validation.OpCreate, posttagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.PostId, input.TagId, input.AssignedAt, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "post_tags",
		Columns:   []string{"id", "post_id", "tag_id", "assigned_at", "created_at", "updated_at"},
		Returning: []string{"id", "post_id", "tag_id", "assigned_at", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*PostTag
	for rows.Next() {
		item := new(PostTag)
		if err := rows.Scan(&item.ID, &item.PostId, &item.TagId, &item.AssignedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("PostTag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *PostTagClient) ByID(ctx context.Context, id string) (*PostTag, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("PostTag", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*PostTag); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, posttagSelectQuery, id)
	out := new(PostTag)
	if err := row.Scan(&out.ID, &out.PostId, &out.TagId, &out.AssignedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("PostTag", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *PostTagClient) List(ctx context.Context, limit, offset int) ([]*PostTag, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, posttagListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*PostTag
	for rows.Next() {
		item := new(PostTag)
		if err := rows.Scan(&item.ID, &item.PostId, &item.TagId, &item.AssignedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *PostTagClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, posttagCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *PostTagClient) Update(ctx context.Context, input *PostTag) (*PostTag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "PostTag", validation.OpUpdate, posttagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, posttagUpdateQuery, input.PostId, input.TagId, input.UpdatedAt, input.ID)
	out := new(PostTag)
	if err := row.Scan(&out.ID, &out.PostId, &out.TagId, &out.AssignedAt, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("PostTag", out.ID), out)
	}
	return out, nil
}

func (c *PostTagClient) BulkUpdate(ctx context.Context, inputs []*PostTag) ([]*PostTag, error) {
	if len(inputs) == 0 {
		return []*PostTag{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "PostTag", validation.OpUpdate, posttagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.PostId, input.TagId, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "post_tags",
		PrimaryColumn: "id",
		Columns:       []string{"post_id", "tag_id", "updated_at"},
		Returning:     []string{"id", "post_id", "tag_id", "assigned_at", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*PostTag
	for rows.Next() {
		item := new(PostTag)
		if err := rows.Scan(&item.ID, &item.PostId, &item.TagId, &item.AssignedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("PostTag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *PostTagClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, posttagDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("PostTag", id))
	}
	return nil
}

func (c *PostTagClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "post_tags",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("PostTag", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type PostTagQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *PostTagClient) Query() *PostTagQuery {
	return &PostTagQuery{db: c.db, defaultLimit: 20, maxLimit: 0}
}

func (q *PostTagQuery) Limit(n int) *PostTagQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *PostTagQuery) Offset(n int) *PostTagQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *PostTagQuery) WhereIDEq(value string) *PostTagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostTagQuery) WherePostIDEq(value string) *PostTagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "post_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostTagQuery) WhereTagIDEq(value string) *PostTagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "tag_id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *PostTagQuery) OrderByAssignedAtDesc() *PostTagQuery {
	q.orders = append(q.orders, runtime.Order{Column: "assigned_at", Direction: runtime.SortDesc})
	return q
}

func (q *PostTagQuery) All(ctx context.Context) ([]*PostTag, error) {
	spec := runtime.SelectSpec{
		Table:      "post_tags",
		Columns:    []string{"id", "post_id", "tag_id", "assigned_at", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*PostTag
	for rows.Next() {
		item := new(PostTag)
		if err := rows.Scan(&item.ID, &item.PostId, &item.TagId, &item.AssignedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *PostTagQuery) Stream(ctx context.Context) (*runtime.Stream[*PostTag], error) {
	spec := runtime.SelectSpec{
		Table:      "post_tags",
		Columns:    []string{"id", "post_id", "tag_id", "assigned_at", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*PostTag](rows, func(rows pgx.Rows) (*PostTag, error) {
		item := new(PostTag)
		if err := rows.Scan(&item.ID, &item.PostId, &item.TagId, &item.AssignedAt, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *PostTagQuery) First(ctx context.Context) (*PostTag, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *PostTagQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "post_tags",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *PostTagQuery) clone() *PostTagQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *PostTagQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const posttagPostRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts WHERE id IN (%s)`

func (c *PostTagClient) LoadPost(ctx context.Context, parents ...*PostTag) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostTagEdges(parent)
		edges.markLoaded("post")
		fk := parent.PostId
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(posttagPostRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Post, len(keys))
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.PostId
		edges := ensurePostTagEdges(parent)
		if isZero(fk) {
			edges.Post = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Post = item
		} else {
			edges.Post = nil
		}
	}
	return nil
}

const posttagTagRelationQuery = `SELECT id, name, slug, description, created_at, updated_at FROM tags WHERE id IN (%s)`

func (c *PostTagClient) LoadTag(ctx context.Context, parents ...*PostTag) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensurePostTagEdges(parent)
		edges.markLoaded("tag")
		fk := parent.TagId
		if isZero(fk) {
			edges.Tag = nil
			continue
		}
		if _, ok := seen[fk]; !ok {
			seen[fk] = struct{}{}
			keys = append(keys, fk)
		}
	}
	if len(keys) == 0 {
		return nil
	}
	sql, args := buildInQuery(posttagTagRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	related := make(map[keyType]*Tag, len(keys))
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		key := item.ID
		related[key] = item
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		fk := parent.TagId
		edges := ensurePostTagEdges(parent)
		if isZero(fk) {
			edges.Tag = nil
			continue
		}
		if item, ok := related[fk]; ok {
			edges.Tag = item
		} else {
			edges.Tag = nil
		}
	}
	return nil
}

const tagInsertQuery = `INSERT INTO tags (id, name, slug, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, slug, description, created_at, updated_at`
const tagSelectQuery = `SELECT id, name, slug, description, created_at, updated_at FROM tags WHERE id = $1`
const tagListQuery = `SELECT id, name, slug, description, created_at, updated_at FROM tags ORDER BY id LIMIT $1 OFFSET $2`
const tagUpdateQuery = `UPDATE tags SET name = $1, slug = $2, description = $3, updated_at = $4 WHERE id = $5 RETURNING id, name, slug, description, created_at, updated_at`
const tagCountQuery = `SELECT COUNT(*) FROM tags`
const tagDeleteQuery = `DELETE FROM tags WHERE id = $1`

type TagClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *TagClient) Create(ctx context.Context, input *Tag) (*Tag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpCreate, tagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, tagInsertQuery, input.ID, input.Name, input.Slug, input.Description, input.CreatedAt, input.UpdatedAt)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Tag", out.ID), out)
	}
	return out, nil
}

func (c *TagClient) BulkCreate(ctx context.Context, inputs []*Tag) ([]*Tag, error) {
	if len(inputs) == 0 {
		return []*Tag{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpCreate, tagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Name, input.Slug, input.Description, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "tags",
		Columns:   []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Returning: []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Tag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *TagClient) ByID(ctx context.Context, id string) (*Tag, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("Tag", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*Tag); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, tagSelectQuery, id)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("Tag", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *TagClient) List(ctx context.Context, limit, offset int) ([]*Tag, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, tagListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *TagClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, tagCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *TagClient) Update(ctx context.Context, input *Tag) (*Tag, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpUpdate, tagValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, tagUpdateQuery, input.Name, input.Slug, input.Description, input.UpdatedAt, input.ID)
	out := new(Tag)
	if err := row.Scan(&out.ID, &out.Name, &out.Slug, &out.Description, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("Tag", out.ID), out)
	}
	return out, nil
}

func (c *TagClient) BulkUpdate(ctx context.Context, inputs []*Tag) ([]*Tag, error) {
	if len(inputs) == 0 {
		return []*Tag{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "Tag", validation.OpUpdate, tagValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Name, input.Slug, input.Description, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "tags",
		PrimaryColumn: "id",
		Columns:       []string{"name", "slug", "description", "updated_at"},
		Returning:     []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("Tag", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *TagClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, tagDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("Tag", id))
	}
	return nil
}

func (c *TagClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "tags",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("Tag", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type TagQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *TagClient) Query() *TagQuery {
	return &TagQuery{db: c.db, defaultLimit: 20, maxLimit: 0}
}

func (q *TagQuery) Limit(n int) *TagQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *TagQuery) Offset(n int) *TagQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *TagQuery) WhereIDEq(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *TagQuery) WhereSlugEq(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "slug", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *TagQuery) WhereNameILike(value string) *TagQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "name", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *TagQuery) OrderByCreatedAtDesc() *TagQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *TagQuery) OrderByNameAsc() *TagQuery {
	q.orders = append(q.orders, runtime.Order{Column: "name", Direction: runtime.SortAsc})
	return q
}

func (q *TagQuery) All(ctx context.Context) ([]*Tag, error) {
	spec := runtime.SelectSpec{
		Table:      "tags",
		Columns:    []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Tag
	for rows.Next() {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *TagQuery) Stream(ctx context.Context) (*runtime.Stream[*Tag], error) {
	spec := runtime.SelectSpec{
		Table:      "tags",
		Columns:    []string{"id", "name", "slug", "description", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*Tag](rows, func(rows pgx.Rows) (*Tag, error) {
		item := new(Tag)
		if err := rows.Scan(&item.ID, &item.Name, &item.Slug, &item.Description, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *TagQuery) First(ctx context.Context) (*Tag, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *TagQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "tags",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *TagQuery) clone() *TagQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *TagQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const userInsertQuery = `INSERT INTO users (id, username, email, name, bio, avatar_url, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, username, email, name, bio, avatar_url, display_name, created_at, updated_at`
const userSelectQuery = `SELECT id, username, email, name, bio, avatar_url, display_name, created_at, updated_at FROM users WHERE id = $1`
const userListQuery = `SELECT id, username, email, name, bio, avatar_url, display_name, created_at, updated_at FROM users ORDER BY id LIMIT $1 OFFSET $2`
const userUpdateQuery = `UPDATE users SET username = $1, email = $2, name = $3, bio = $4, avatar_url = $5, updated_at = $6 WHERE id = $7 RETURNING id, username, email, name, bio, avatar_url, display_name, created_at, updated_at`
const userCountQuery = `SELECT COUNT(*) FROM users`
const userDeleteQuery = `DELETE FROM users WHERE id = $1`

type UserClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *UserClient) Create(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.DisplayName) {
		return nil, fmt.Errorf("User.DisplayName is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, userInsertQuery, input.ID, input.Username, input.Email, input.Name, input.Bio, input.AvatarUrl, input.CreatedAt, input.UpdatedAt)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Name, &out.Bio, &out.AvatarUrl, &out.DisplayName, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkCreate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		now := time.Now().UTC()
		if !runtime.IsZeroValue(input.DisplayName) {
			return nil, fmt.Errorf("User.DisplayName is computed and cannot be set")
		}
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.Username, input.Email, input.Name, input.Bio, input.AvatarUrl, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "users",
		Columns:   []string{"id", "username", "email", "name", "bio", "avatar_url", "created_at", "updated_at"},
		Returning: []string{"id", "username", "email", "name", "bio", "avatar_url", "display_name", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *UserClient) ByID(ctx context.Context, id string) (*User, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("User", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*User); ok {
				return entity, nil
			}
		}
	}
	row := c.db.Pool.QueryRow(ctx, userSelectQuery, id)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Name, &out.Bio, &out.AvatarUrl, &out.DisplayName, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("User", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *UserClient) List(ctx context.Context, limit, offset int) ([]*User, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, userListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *UserClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, userCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *UserClient) Update(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	row := c.db.Pool.QueryRow(ctx, userUpdateQuery, input.Username, input.Email, input.Name, input.Bio, input.AvatarUrl, input.UpdatedAt, input.ID)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Username, &out.Email, &out.Name, &out.Bio, &out.AvatarUrl, &out.DisplayName, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkUpdate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.Username, input.Email, input.Name, input.Bio, input.AvatarUrl, input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "users",
		PrimaryColumn: "id",
		Columns:       []string{"username", "email", "name", "bio", "avatar_url", "updated_at"},
		Returning:     []string{"id", "username", "email", "name", "bio", "avatar_url", "display_name", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *UserClient) Delete(ctx context.Context, id string) error {
	if _, err := c.db.Pool.Exec(ctx, userDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("User", id))
	}
	return nil
}

func (c *UserClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "users",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	tag, err := c.db.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("User", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type UserQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *UserClient) Query() *UserQuery {
	return &UserQuery{db: c.db, defaultLimit: 20, maxLimit: 0}
}

func (q *UserQuery) Limit(n int) *UserQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *UserQuery) Offset(n int) *UserQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *UserQuery) WhereIDEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) WhereUsernameEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "username", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) WhereEmailILike(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "email", Operator: runtime.OpILike, Value: value})
	return q
}

func (q *UserQuery) OrderByCreatedAtDesc() *UserQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortDesc})
	return q
}

func (q *UserQuery) OrderByUsernameAsc() *UserQuery {
	q.orders = append(q.orders, runtime.Order{Column: "username", Direction: runtime.SortAsc})
	return q
}

func (q *UserQuery) All(ctx context.Context) ([]*User, error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "username", "email", "name", "bio", "avatar_url", "display_name", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *UserQuery) Stream(ctx context.Context) (*runtime.Stream[*User], error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "username", "email", "name", "bio", "avatar_url", "display_name", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*User](rows, func(rows pgx.Rows) (*User, error) {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Name, &item.Bio, &item.AvatarUrl, &item.DisplayName, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *UserQuery) First(ctx context.Context) (*User, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *UserQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "users",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *UserQuery) clone() *UserQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *UserQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}

const userPostsRelationQuery = `SELECT id, author_id, category_id, title, slug, excerpt, body, published_at, is_published, created_at, updated_at FROM posts WHERE author_id IN (%s)`

func (c *UserClient) LoadPosts(ctx context.Context, parents ...*User) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*User, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureUserEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureUserEdges(parent)
			if edges.Posts == nil {
				edges.Posts = []*Post{}
			}
			edges.markLoaded("posts")
		}
		return nil
	}
	sql, args := buildInQuery(userPostsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Post)
		if err := rows.Scan(&item.ID, &item.AuthorId, &item.CategoryId, &item.Title, &item.Slug, &item.Excerpt, &item.Body, &item.PublishedAt, &item.IsPublished, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		owner := item.AuthorId
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureUserEdges(parent)
			edges.Posts = append(edges.Posts, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureUserEdges(parent)
		if edges.Posts == nil {
			edges.Posts = []*Post{}
		}
		edges.markLoaded("posts")
	}
	return nil
}

const userCommentsRelationQuery = `SELECT id, post_id, author_id, parent_id, body, is_edited, created_at, updated_at FROM comments WHERE author_id IN (%s)`

func (c *UserClient) LoadComments(ctx context.Context, parents ...*User) error {
	if len(parents) == 0 {
		return nil
	}
	type keyType = string
	keys := make([]keyType, 0, len(parents))
	seen := make(map[keyType]struct{}, len(parents))
	buckets := make(map[keyType][]*User, len(parents))
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		key := parent.ID
		if isZero(key) {
			edges := ensureUserEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
			continue
		}
		if _, ok := seen[key]; !ok {
			seen[key] = struct{}{}
			keys = append(keys, key)
		}
		buckets[key] = append(buckets[key], parent)
	}
	if len(keys) == 0 {
		for _, parent := range parents {
			if parent == nil {
				continue
			}
			edges := ensureUserEdges(parent)
			if edges.Comments == nil {
				edges.Comments = []*Comment{}
			}
			edges.markLoaded("comments")
		}
		return nil
	}
	sql, args := buildInQuery(userCommentsRelationQuery, keys)
	rows, err := c.db.Pool.Query(ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		item := new(Comment)
		if err := rows.Scan(&item.ID, &item.PostId, &item.AuthorId, &item.ParentId, &item.Body, &item.IsEdited, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return err
		}
		owner := item.AuthorId
		parents, ok := buckets[owner]
		if !ok {
			continue
		}
		for _, parent := range parents {
			edges := ensureUserEdges(parent)
			edges.Comments = append(edges.Comments, item)
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}
	for _, parent := range parents {
		if parent == nil {
			continue
		}
		edges := ensureUserEdges(parent)
		if edges.Comments == nil {
			edges.Comments = []*Comment{}
		}
		edges.markLoaded("comments")
	}
	return nil
}

func categoryValidationRecord(input *Category) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"Name":        input.Name,
		"Slug":        input.Slug,
		"Description": input.Description,
		"Color":       input.Color,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func commentValidationRecord(input *Comment) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":        input.ID,
		"PostId":    input.PostId,
		"AuthorId":  input.AuthorId,
		"ParentId":  input.ParentId,
		"Body":      input.Body,
		"IsEdited":  input.IsEdited,
		"CreatedAt": input.CreatedAt,
		"UpdatedAt": input.UpdatedAt,
	}
}

func postValidationRecord(input *Post) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"AuthorId":    input.AuthorId,
		"CategoryId":  input.CategoryId,
		"Title":       input.Title,
		"Slug":        input.Slug,
		"Excerpt":     input.Excerpt,
		"Body":        input.Body,
		"PublishedAt": input.PublishedAt,
		"IsPublished": input.IsPublished,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func posttagValidationRecord(input *PostTag) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":         input.ID,
		"PostId":     input.PostId,
		"TagId":      input.TagId,
		"AssignedAt": input.AssignedAt,
		"CreatedAt":  input.CreatedAt,
		"UpdatedAt":  input.UpdatedAt,
	}
}

func tagValidationRecord(input *Tag) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":          input.ID,
		"Name":        input.Name,
		"Slug":        input.Slug,
		"Description": input.Description,
		"CreatedAt":   input.CreatedAt,
		"UpdatedAt":   input.UpdatedAt,
	}
}

func userValidationRecord(input *User) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":        input.ID,
		"Username":  input.Username,
		"Email":     input.Email,
		"Name":      input.Name,
		"Bio":       input.Bio,
		"AvatarUrl": input.AvatarUrl,
		"CreatedAt": input.CreatedAt,
		"UpdatedAt": input.UpdatedAt,
	}
}

func buildInQuery[T any](base string, values []T) (string, []any) {
	if len(values) == 0 {
		return base, nil
	}
	placeholders := make([]string, len(values))
	args := make([]any, len(values))
	for i := range values {
		placeholders[i] = fmt.Sprintf("$%d", i+1)
		args[i] = values[i]
	}
	return fmt.Sprintf(base, strings.Join(placeholders, ", ")), args
}

func isZero[T comparable](v T) bool {
	var zero T
	return v == zero
}
